<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>R面向对象编程S4 - Yulong Niu</title><link rel="icon" type="image/png" href=icons/favicon.ico /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="R面向对象编程S4" />
<meta property="og:description" content="R S4简介。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://YulongNiu.github.io/posts/2012-05-05-r-s4/" />
<meta property="article:published_time" content="2012-05-05T15:19:36+08:00" />
<meta property="article:modified_time" content="2012-05-05T15:19:36+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="R面向对象编程S4"/>
<meta name="twitter:description" content="R S4简介。"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">
  <link rel="stylesheet" type="text/css" media="screen" href="/css/bootstrap-table.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" href="/css/custom.css" />
	<link rel="stylesheet" type="text/css" href="/css/dark.css" media="(prefers-color-scheme: dark)" />
	<link rel="stylesheet" type="text/css" href="/css/custom-dark.css" media="(prefers-color-scheme: dark)" />

	
	
	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="/js/main.js"></script>
	<script src="https://YulongNiu.github.io/js/abc.js"></script>
	<script src="https://YulongNiu.github.io/js/xyz.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title"><a href="https://YulongNiu.github.io/">Yulong Niu</a></h1>
	<div class="site-description"><h2>个人博客</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/YulongNiu" title="Github"><i data-feather="github"></i></a><a href="https://twitter.com/YulongNiu" title="Twitter"><i data-feather="twitter"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">Posts</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">R面向对象编程S4</h1>
			<div class="meta">Posted at &mdash; May 5, 2012</div>
		</div>

		<div class="markdown">
			

<h2 id="1-一些s3的铺垫">1. 一些S3的铺垫</h2>

<p>在博文“<a href="http://yulongniu.bionutshell.org/blog/2010/09/04/linux-install-r/">Linux安装R语言包</a>”描述了如何查看一个函数的源代码，其中涉及了例如<code>methods()</code>函数，用来查看一个S3泛函（S3 generic）的方法。在<span style="color: blue">pryr</span>包中，提供了更加便捷的查看方法。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">library(<span style="color:#a31515">&#39;pryr&#39;</span>)

<span style="color:#008000">## object is base type, S3, S4 or RC</span>
otype(obj)

<span style="color:#008000">## function is genetic or method</span>
ftype(method)</code></pre></div>
<h2 id="2-类">2. 类</h2>

<h3 id="2-1-建立新类">2.1 建立新类</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setClass(Class, representation, prototype, contains=character(),
         validity, access, where, version, sealed, package,
         S3methods = FALSE, slots)</pre></div>
<blockquote>
<ul>
<li><p>Class：类名。</p></li>

<li><p>slots：带名字的列表或者字符向量，名字表示slot，内容表示slot对应的类名。</p></li>

<li><p>contains：父类名，表示继承关系。</p></li>

<li><p>prototype：带名setGroupGeneric字的列表或<code>prototype()</code>，设定默认值。不建议添加，如果不设定，会自动指定一个符合类型的空值。设定时，要结合<code>validity</code>定义，因为默认值不会被检查，因为即使不符合<code>validity</code>定义，也可以通过<code>validObject()</code>检查。</p></li>

<li><p>validity：函数，检查创建对象是否符合该类要求。建议添加，也可以使用<code>setValidity()</code>后期添加。</p></li>

<li><p>where：环境（少用）。</p></li>

<li><p>sealed：是否封闭，如果设定为<code>TRUE</code>，其他<code>setClass()</code>不能调用该类。</p></li>

<li><p>package：包名（少用）</p></li>

<li><p>S3methods/representation/access/version：在3.0.0版本后不建议使用。</p></li>
</ul>
</blockquote>

<p>例子：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#008000">## new class</span>
setClass(Class = <span style="color:#a31515">&#39;trick&#39;</span>,
         slots = c(id = <span style="color:#a31515">&#39;character&#39;</span>, time = <span style="color:#a31515">&#39;matrix&#39;</span>),
         validity = function(object) {
           if (length(object@id) != nrow(object@time)) {
             warns &lt;- paste(<span style="color:#a31515">&#39;length of id is&#39;</span>, length(object@id), <span style="color:#a31515">&#39;is not equal to row number of time&#39;</span>, nrow(object@time))
             return(warns)
           } else {
             return(<span style="color:#00f">TRUE</span>)
           }},
         prototype = list(id = character(), time = matrix(0, 0, 0)))

setClass(Class = <span style="color:#a31515">&#39;trickNum&#39;</span>,
         slots = c(number = <span style="color:#a31515">&#39;numeric&#39;</span>),
         contains = <span style="color:#a31515">&#39;trick&#39;</span>)

setClass(Class = <span style="color:#a31515">&#39;trickMult&#39;</span>,
         slots = c(trick1 = <span style="color:#a31515">&#39;trick&#39;</span>, trick2 = <span style="color:#a31515">&#39;trick&#39;</span>))

<span style="color:#008000">## from setClass() help document, extend from built-in data type</span>
setClass(<span style="color:#a31515">&#34;numWithId&#34;</span>, 
         slots = c(id = <span style="color:#a31515">&#34;character&#34;</span>),
         contains = <span style="color:#a31515">&#34;numeric&#34;</span>)

numWI1 &lt;- new(<span style="color:#a31515">&#39;numWithId&#39;</span>, 1:10, id = <span style="color:#00f">letters</span>[1:10])
<span style="color:#008000">## retrieve data of numWI1</span>
numWI1@.Data

<span style="color:#008000">## without slots</span>
numNoSlot &lt;- setClass(<span style="color:#a31515">&#34;num&#34;</span>, contains = <span style="color:#a31515">&#34;numeric&#34;</span>)

<span style="color:#008000">## simplest class</span>
setClass(Class = <span style="color:#a31515">&#39;simpleClass&#39;</span>)</code></pre></div>
<p>使用<code>setOldClass()</code>转换S3类型对象，使用<code>getClass('oldClass')</code>查询oldClass。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">structure(list(), class = <span style="color:#a31515">&#39;TestS3Class&#39;</span>)

setOldClass(<span style="color:#a31515">&#39;TestS3Class&#39;</span>)</code></pre></div>
<h3 id="2-2-创建-查看和删除对象">2.2 创建、查看和删除对象</h3>

<p>创建对象：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">new(Class, ...)</pre></div>
<blockquote>
<ul>
<li><p>Class：类名。</p></li>

<li><p>&hellip;：各个slot赋值。如果没有赋值，则使用初始化值。</p></li>
</ul>
</blockquote>

<p>在使用<code>new()</code>建立新的对象之前，会经历“初始化”。初始化可以对新建对象做一些事先固定的操作，比如给某一个slot添加名字等。这需要使用<code>setMethod()</code>重新定义<code>initialize()</code>泛函，考虑使用<code>callNextMethod()</code>，以保证子类也能够继承初始化，同时需要考虑“空对象”问题。由于<code>callNextMethod()</code>是向父类搜索，在有很多继承关系时，搜索结果会变得难以预测，因此尽量减少使用。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#008000">## first initialize can not be correctly inherited</span>
setMethod(f = <span style="color:#a31515">&#39;initialize&#39;</span>,
          signature = <span style="color:#a31515">&#39;trick&#39;</span>,
          definition = function(.Object, id = character(), time = matrix(0, 0, 0)) {

            colNum &lt;- ncol(time)
            if (colNum &gt; 0) {
              colnames(time) &lt;- paste0(<span style="color:#00f">letters</span>[1:colNum], 1:colNum)
            } else {}

            .Object@id &lt;- id
            .Object@time &lt;- time

            return(.Object)
          })
t1 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3))
try(new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3), number = 5:6))

<span style="color:#008000">## second initialize can not be correctly inherited</span>
setMethod(f = <span style="color:#a31515">&#39;initialize&#39;</span>,
          signature = <span style="color:#a31515">&#39;trick&#39;</span>,
          definition = function(.Object, <span style="color:#00f">...</span>) {

            colNum &lt;- ncol(.Object@time)
            if (colNum &gt; 0) {
              colnames(.Object@time) &lt;- paste0(<span style="color:#00f">letters</span>[1:colNum], 1:colNum)
            } else {}

            return(.Object)
          })
try(new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3)))
<span style="color:#008000">## not as expected, all slots are empty</span>
try(new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3), number = 5:6))

<span style="color:#008000">## third initialize using callNextMethod() works well</span>
setMethod(f = <span style="color:#a31515">&#39;initialize&#39;</span>,
          signature = <span style="color:#a31515">&#39;trick&#39;</span>,
          definition = function(.Object, <span style="color:#00f">...</span>) {

            .Object &lt;- callNextMethod()

            colNum &lt;- ncol(.Object@time)
            if (colNum &gt; 0) {
              colnames(.Object@time) &lt;- paste0(<span style="color:#00f">letters</span>[1:colNum], 1:colNum)
            } else {}

            return(.Object)
          })
t1 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3))
tn1 &lt;- new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3), number = 5:6)</code></pre></div>
<p>查看对象和类：</p>

<ul>
<li><p><code>getClass('className')</code>：查询一个类的情况，也包括该类的继承情况。返回结果的“Subclasses”表示含有的子类，“Extends”表示父类是什么。</p></li>

<li><p><code>getSlots('className')</code>：查询某一个class的slots。</p></li>

<li><p><code>slotNames(objName)</code>：查询一个对象的slots名称。</p></li>

<li><p><code>@</code>和<code>slot(objName, 'slotName')</code>：查询一个对象的slot的值。也可以使用<code>objName@slotName &lt;- somVal</code>和<code>slot(objName, 'slotName') &lt;- someVal</code>赋值，只会检查slot对应的类型，不会检查<code>validity</code>设定。一定不要执行<code>slot(objName, 'slotName', check = FALSE) &lt;- someVal</code>，否则连类型都不检查。<code>@</code>定义在<span style="color: blue">base</span>包，<code>slot()</code>在<span style="color: blue">methods</span>包。</p></li>

<li><p><code>.hasSlot(objName, 'slotName')</code>：查询一个对象是否有某个slot。</p></li>

<li><p><code>is(myObj, 'myClass')</code>：判断某个对象是否属于类，会向上查找父类，如果对象属于父类，也返回<code>TRUE</code>。<code>is(MyOb)</code>，返回某个对象的类和所有父类。</p></li>
</ul>

<p>删除对象：</p>

<ul>
<li><code>removeClass('className')</code>：删除类，但是会保留这个类的方法和子类。</li>
</ul>

<h2 id="3-方法">3. 方法</h2>

<h3 id="3-1-建立方法">3.1 建立方法</h3>

<p>方法和泛函的关系非常密切，某一个方法必须建立在一个特定泛函下。因此，建立方法时，首先确定该方法是否存在泛函：</p>

<ul>
<li><p>如果不存在，首先使用<code>setGeneric()</code>建立泛函；</p></li>

<li><p>如果存在，使用<code>setMethod()</code>建立具体方法。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setGeneric(name, def= , group=list(), valueClass=character(),
       where= , package= , signature= , useAsDefault= ,
       genericFunction= , simpleInheritanceOnly = )</pre></div></li>
</ul>

<blockquote>
<ul>
<li><p>name：字符串，泛函名称。</p></li>

<li><p>def：函数，定义新的泛函，比如结合<code>standardGeneric()</code>函数。参数默认值在这里定义，后面的具体方法中参数默认值无效。</p></li>

<li><p>group：字符串，指示该泛函所属的泛函组。</p></li>

<li><p>valueClass：字符向量，一个或多个类，强制规定该泛函返回类型必须符合或包括类。</p></li>

<li><p>where：环境（少用）。</p></li>

<li><p>package：包名，一般自动识别。</p></li>

<li><p>signature：名字向量。</p></li>

<li><p>useAsDefault：推翻默认设置。</p></li>

<li><p>genericFunction：不建议使用。</p></li>

<li><p>simpleInheritanceOnly：逻辑值。</p></li>
</ul>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setMethod(f, signature=character(), definition,
          where = topenv(parent.frame()),
          valueClass = NULL, sealed = FALSE)</pre></div>
<blockquote>
<ul>
<li><p>f：字符串，泛函名称。</p></li>

<li><p>signature：字符向量，指定<code>definition</code>中函数变量对应的类名。两个特殊类<code>&quot;missing&quot;</code>和<code>&quot;ANY&quot;</code>，分别表示对应的变量“不能出现在方法调用中”和“可以是任何类”。如果一个变量没有被指定，则默认为<code>&quot;ANY&quot;</code>。</p></li>

<li><p>definition：函数，定义方法。在创建函数时，特别是扩展已有泛函，<code>f(para)</code>中的变量与原始泛函的数量和名称一致。比如在<code>print(x, ...)</code>，变量是<code>x</code>和<code>...</code>。而在<code>show(object)</code>中，变量是<code>x</code>。可以使用<code>args()</code>查看泛函的参数。同时，函数中可以含有未被定义的变量<code>...</code>，后面<code>setMethod()</code>方法可以添加泛函声明变量之外的变量；如果没有<code>...</code>，后续方法只能操作泛函申明的变量。</p></li>

<li><p>where：环境（少用）。</p></li>

<li><p>valueClass：废弃变量。</p></li>

<li><p>sealed：是否封闭，如果设定为<code>TRUE</code>，其他<code>setMethod()</code>不能重新定义该方法，但可以被删除和重新指定。</p></li>
</ul>
</blockquote>

<p>对于一个对象，可以用一个泛函处理多个不同情况，比如不同的类（包括<code>&quot;missing&quot;</code>和<code>&quot;ANY&quot;</code>）、父类/子类。同时，子类会自动继承父类的方法。但是，如果子类定义了与父类名称相同的方法，则父类方法不再起作用。需要强制“回溯”父类方法，使用<code>callNextMethod()</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#008000">## plot() is initially not a S4 generic function, </span>
<span style="color:#008000">## but was automatically created.</span>
<span style="color:#008000">## it is equalt to setGeneric(&#39;plot&#39;)</span>
setMethod(f = <span style="color:#a31515">&#39;plot&#39;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trick&#39;</span>),
          definition = function(x, y, <span style="color:#00f">...</span>) {
            matplot(x = slot(x, <span style="color:#a31515">&#39;time&#39;</span>), pch = slot(x, <span style="color:#a31515">&#39;id&#39;</span>))
          })

<span style="color:#008000">## set new generic function</span>
setGeneric(name = <span style="color:#a31515">&#39;Add&#39;</span>, def = function(x, y, <span style="color:#00f">...</span>){standardGeneric(<span style="color:#a31515">&#39;Add&#39;</span>)})

<span style="color:#008000">## test &#34;missing&#34; class</span>
setMethod(f = <span style="color:#a31515">&#39;Add&#39;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trick&#39;</span>, y = <span style="color:#a31515">&#39;missing&#39;</span>),
          definition = function(x, y, <span style="color:#00f">...</span>) {
            slot(x, <span style="color:#a31515">&#39;time&#39;</span>) &lt;- slot(x, <span style="color:#a31515">&#39;time&#39;</span>) + 1
            return(x)
          })

<span style="color:#008000">## another function</span>
setMethod(f = <span style="color:#a31515">&#39;Add&#39;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trick&#39;</span>, y = <span style="color:#a31515">&#39;numeric&#39;</span>),
          definition = function(x, y, <span style="color:#00f">...</span>) {
            slot(x, <span style="color:#a31515">&#39;time&#39;</span>) &lt;- slot(x, <span style="color:#a31515">&#39;time&#39;</span>) + y
            return(x)
          })

<span style="color:#008000">## with one more parameter &#34;isabs&#34;</span>
<span style="color:#008000">## which is not defined in the generic function</span>
<span style="color:#008000">## thank for &#34;...&#34;</span>
setMethod(f = <span style="color:#a31515">&#39;Add&#39;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trick&#39;</span>, y = <span style="color:#a31515">&#39;numeric&#39;</span>),
          definition = function(x, y, isabs = <span style="color:#00f">FALSE</span>, <span style="color:#00f">...</span>) {
            slot(x, <span style="color:#a31515">&#39;time&#39;</span>) &lt;- slot(x, <span style="color:#a31515">&#39;time&#39;</span>) + ifelse(isabs, abs(y), y)
            return(x)
          })
<span style="color:#008000">## getMethod</span>
getMethod(<span style="color:#a31515">&#39;Add&#39;</span>, c(<span style="color:#a31515">&#39;trick&#39;</span>, <span style="color:#a31515">&#39;numeric&#39;</span>))

Add(t1)
Add(t1, -1)
Add(t1, -1, isabs = <span style="color:#00f">TRUE</span>)
Add(tn1, -1, isabs = <span style="color:#00f">TRUE</span>)

<span style="color:#008000">## test callNextMethod()</span>
setMethod(f = <span style="color:#a31515">&#39;Add&#39;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trickNum&#39;</span>, y = <span style="color:#a31515">&#39;numeric&#39;</span>),
          definition = function(x, y, callNext = <span style="color:#00f">FALSE</span>, <span style="color:#00f">...</span>) {
            if (callNext) {
              x &lt;- callNextMethod()
            } else {}
            slot(x, <span style="color:#a31515">&#39;number&#39;</span>) &lt;- slot(x, <span style="color:#a31515">&#39;number&#39;</span>) + y
            return(x)
          })
Add(tn1, -1)
Add(tn1, -1, callNext = <span style="color:#00f">TRUE</span>, isabs = <span style="color:#00f">TRUE</span>)</code></pre></div>
<h3 id="3-2-获取和修改对象">3.2 获取和修改对象</h3>

<p>重置<code>[</code>、<code>[[</code>和<code>$</code>获取对象。重置<code>[&lt;-</code>、<code>[[&lt;-</code>和<code>$&lt;-</code>修改对象（改变原始对象），建议使用<code>validObject()</code>检查修改后的对象。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#008000">## set &#34;[&#34; and &#34;[&lt;-&#34;</span>
setMethod(f = <span style="color:#a31515">&#34;[&#34;</span>,
          signature = c(x = <span style="color:#a31515">&#39;trickNum&#39;</span>),
          definition = function(x, i, j, <span style="color:#00f">...</span>, drop) {
            return(slot(x, i))
          })

setMethod(f = <span style="color:#a31515">&#34;[&lt;-&#34;</span>,
          signature = <span style="color:#a31515">&#39;trickNum&#39;</span>,
          definition = function(x, i, j, <span style="color:#00f">...</span>, value) {
            slot(x, i) &lt;- value
            validObject(x)
            return(x)
          })

tn1[<span style="color:#a31515">&#39;time&#39;</span>]
try(tn1[<span style="color:#a31515">&#39;joke&#39;</span>])
tn1[<span style="color:#a31515">&#39;id&#39;</span>] &lt;- <span style="color:#00f">LETTERS</span>[1:3]
try(tn1[<span style="color:#a31515">&#39;id&#39;</span>] &lt;- <span style="color:#00f">LETTERS</span>[1:4])

<span style="color:#008000">## define &#34;numData&#34; and &#34;numData&lt;-&#34;</span>
setGeneric(name = <span style="color:#a31515">&#39;numData&#39;</span>, def = function(x, <span style="color:#00f">...</span>){standardGeneric(<span style="color:#a31515">&#39;numData&#39;</span>)})
setGeneric(name = <span style="color:#a31515">&#39;numData&lt;-&#39;</span>, def = function(x, value, <span style="color:#00f">...</span>){standardGeneric(<span style="color:#a31515">&#39;numData&lt;-&#39;</span>)})

setMethod(f = <span style="color:#a31515">&#34;numData&#34;</span>,
          signature = <span style="color:#a31515">&#39;numWithId&#39;</span>,
          definition = function(x, <span style="color:#00f">...</span>) {
            return(x@.Data)
          })

setMethod(f = <span style="color:#a31515">&#34;numData&lt;-&#34;</span>,
          signature = c(x = <span style="color:#a31515">&#39;numWithId&#39;</span>, value = <span style="color:#a31515">&#39;numeric&#39;</span>),
          definition = function(x, value, <span style="color:#00f">...</span>) {
            x@.Data = value
            validObject(x)
            return(x)
          })

numData(numWI1)
numData(numWI1) &lt;- 10:1</code></pre></div>
<h3 id="3-3-泛函组">3.3 泛函组</h3>

<p>S4允许将一类方法定义为“泛函组（group generic functions）”。已经定义的泛函组，比如<code>ops</code>，通过<code>?S4groupGeneric</code>查看。使用<code>setGroupGeneric()</code>定义新的泛函组，使用<code>callGeneric()</code>调用泛函组，比如：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">setMethod(<span style="color:#a31515">&#39;Ops&#39;</span>,
          signature(e1=<span style="color:#a31515">&#39;trick&#39;</span>, e2=<span style="color:#a31515">&#39;trick&#39;</span>),
          function(e1, e2) {
            e1@time &lt;- callGeneric(slot(e1, <span style="color:#a31515">&#39;time&#39;</span>), slot(e2, <span style="color:#a31515">&#39;time&#39;</span>))
            validObject(e1)
            return(e1)
          })

t1 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3))
t2 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(9:1, ncol = 3))
t1 + t2</code></pre></div>
<h3 id="3-4-查看和删除方法">3.4 查看和删除方法</h3>

<p>查看方法：</p>

<ul>
<li><p><code>methods('fun')</code>：查看某个函数的具体信息，根据结果判断是否为S4。</p></li>

<li><p><code>getGeneric('genfun')</code>：查看某个泛函的定义。</p></li>

<li><p><code>findMethods('genfun')</code>：查看某个泛函的代码。</p></li>

<li><p><code>showMethods('genfun', classes = 'myClass')</code>：某个泛函的总结信息，可以指定类。也可以只声明<code>classes</code>，从而查看某些类的全部方法。</p></li>

<li><p><code>getMethod('myMethod', 'myClass')</code>和<code>selectMethod('genfun', 'myClass')</code>：查看某个类的某个方法的具体代码，前者只查找制定的类，后者会向父类查找直到找到为止。</p></li>

<li><p><code>existsMethod('myMethod', 'myClass')</code>和<code>hasMethod('genfun', 'myClass')</code>：判断某个类是否有某个方法，前者只查找制定的类，后者会向父类查找直到找到为止。</p></li>
</ul>

<p>删除方法：</p>

<ul>
<li><p><code>removeGeneric('genfun')</code>：删除泛函。</p></li>

<li><p><code>removeMethods('myMethod')</code>：删除方法。</p></li>
</ul>

<h2 id="4-确认检查">4. 确认检查</h2>

<p>创建对象时：</p>

<ol>
<li><p>自动检查每个slot赋值类型是否正确，这种检查会一直被子类和slot含有该类的类（简称“slot含有类”）继承。</p></li>

<li><p>如果设定了<code>validity</code>，这种检查将一直被子类继承，但是slot含有类不会去检查slot赋值是否正确。对于这种情况，将<code>validObject(object, test = FALSE, complete = FALSE)</code>函数的<code>complete</code>参数设定为<code>TRUE</code>，可以检查出问题。</p></li>

<li><p>如果自定义了<code>initialize()</code>方法，建议使用<code>callNextMethod()</code>的形式，这样会进行<code>setClass()</code>的<code>validity</code>检查。</p></li>
</ol>

<p>修改slot时：</p>

<p>使用<code>slot()</code>和<code>@</code>，只会检查slot类型是否正确，不会检查<code>validity</code>设定。不建议用户直接使用<code>@</code>。</p>

<p>推荐在<code>setClass()</code>建立类时，同时设定好<code>validity</code>，而不是使用<code>setValidity(Class, method, where = topenv(parent.frame()))</code>后续设定。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#008000">## correct &#34;trick&#34; obj</span>
t1 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3))
<span style="color:#008000">## not validated &#34;trick&#34; obj</span>
t2 &lt;- t1
t2@id &lt;- <span style="color:#00f">letters</span>[1:4]
<span style="color:#008000">## return FALSE</span>
validObject(t2)
<span style="color:#008000">## error</span>
try(new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = 1:4))
try(new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:8, ncol = 4)))

<span style="color:#008000">## correct &#34;trickNum&#34; obj</span>
tn1 &lt;- new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:9, ncol = 3), number = 5:6)
<span style="color:#008000">## error because can not pass &#34;trick&#34; validate</span>
try(new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = 1:4, number = 5:6))
try(new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:8, ncol = 4), number = 5:6))

<span style="color:#008000">## error</span>
try(new(<span style="color:#a31515">&#39;trickMult&#39;</span>, trick1 = new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = 1:4)))
try(new(<span style="color:#a31515">&#39;trickMult&#39;</span>, trick1 = new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">letters</span>[1:3], time = matrix(1:8, ncol = 4))))

tm1 &lt;- new(<span style="color:#a31515">&#39;trickMult&#39;</span>, trick1 = t2)
<span style="color:#008000">## return TRUE</span>
validObject(tm1)
<span style="color:#008000">## return FALSE</span>
validObject(tm1, complete = <span style="color:#00f">TRUE</span>)</code></pre></div>
<h2 id="5-继承">5. 继承</h2>

<h3 id="5-1-类转换">5.1 类转换</h3>

<p><code>setClass()</code>的<code>contains</code>参数规定了继承的父类，很直接的继承关系（simple inheritance）。使用<code>as()</code>（不改变原始对象的值）和<code>as() &lt;- value</code>进行转换。</p>

<p><code>as(myObj, 'myClass')</code>分为三种情况：</p>

<ul>
<li><p><code>myObj</code>是子类对象，<code>myClass</code>是父类，返回只含有父类的slots（“剪枝”）。</p></li>

<li><p><code>myObj</code>是父类对象，<code>myClass</code>是子类，返回多余的子类slots填充默认值。</p></li>

<li><p><code>myObj</code>是<code>myClass</code>的一个对象，没有变化。</p></li>
</ul>

<p><code>as(myObj, 'myClass') &lt;- value</code>有四种特殊情况：</p>

<ul>
<li><p><code>as(objSon1, 'classFather') &lt;- objSon2</code>行为等同于<code>objSon1 &lt;- objSon2</code>。</p></li>

<li><p><code>as(objSon, 'classFather') &lt;- objFather</code>父类slots的值“遗传”给子类，返回<code>classSon</code>类的对象。</p></li>

<li><p><code>as(objFather1, 'classSon') &lt;- objFather2</code>报错。</p></li>

<li><p><code>as(objFather, 'classSon') &lt;- objSon</code>报错。</p></li>
</ul>

<p>使用<code>setIs()</code>显示继承（explicit inheritance），尽量少用或使用<code>setAs()</code>代替。但是，<code>setIs()</code>使得<code>class1</code>变成<code>class2</code>的子类，<code>class2</code>的一些方法可能失效。因为，两个类的slots可能有很大的不同。因此，使用<code>as()</code>将<code>class1</code>转换成<code>class2</code>，再使<code>class2</code>的方法。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,
      by = character(), where = topenv(parent.frame()), classDef =,
      extensionObject = NULL, doComplete = TRUE)</pre></div>
<blockquote>
<ul>
<li><p>class1：字符串，需要转换的类。</p></li>

<li><p>class2：字符串，目标类。</p></li>

<li><p>test：转化检查，不推荐。</p></li>

<li><p>coerce：函数，一个参数，例如<code>from</code>。目的是从<code>from</code>中提取和处理一些slots，之后用这些处理后的slot建立一个<code>class2</code>的对象并返回。coerce对应的函数就是将<code>class1</code>转化成<code>class2</code>，因此要返回一个<code>class2</code>的对象。这也意味着<code>class1</code>将成为<code>class2</code>的一个子类。使用showMethods(&ldquo;coerce&rdquo;)查询内建的coerce函数。</p></li>

<li><p>replace：函数，目的是实现类似<code>as(obj,&quot;class2&quot;) &lt;- value</code>。变量可以设为两个，例如<code>from</code>和<code>value</code>，最后返回处理好的<code>from</code>。</p></li>

<li><p>by：不建议使用。</p></li>

<li><p>where：设定环境。</p></li>

<li><p>classDef：不建议使用。</p></li>

<li><p>useAsDefault：推翻默认设置。</p></li>

<li><p>extensionObject/doComplete：不建议使用。</p></li>
</ul>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setAs(from, to, def, replace, where = topenv(parent.frame()))</pre></div>
<blockquote>
<ul>
<li><p>from：字符串，需要转换的类。</p></li>

<li><p>to：字符串，目标类。</p></li>

<li><p>def：函数，参数<code>from</code>（<code>from</code>或<code>to</code>），目的是将<code>from</code>转化成<code>to</code>。</p></li>

<li><p>replace：函数，参数<code>from</code>和<code>value</code>，目的是实现类似<code>as(obj,&quot;to&quot;) &lt;- value</code>。</p></li>

<li><p>where：设定环境。</p></li>
</ul>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">t2 &lt;- new(<span style="color:#a31515">&#39;trick&#39;</span>, id = <span style="color:#00f">LETTERS</span>[3:1], time = matrix(9:1, ncol = 3))
tn2 &lt;- new(<span style="color:#a31515">&#39;trickNum&#39;</span>, id = <span style="color:#00f">LETTERS</span>[3:1], time = matrix(10:2, ncol = 3), number = 5:6)

as(tn2, <span style="color:#a31515">&#39;trick&#39;</span>)
as(t2, <span style="color:#a31515">&#39;trickNum&#39;</span>)

as(tn2, <span style="color:#a31515">&#39;trick&#39;</span>) &lt;- tn1
as(tn2, <span style="color:#a31515">&#39;trick&#39;</span>) &lt;- t2
try(as(t2, <span style="color:#a31515">&#39;trickNum&#39;</span>) &lt;- tn1)
try(as(t2, <span style="color:#a31515">&#39;trickNum&#39;</span>) &lt;- t1)

setClass(Class = <span style="color:#a31515">&#39;trickNumMat&#39;</span>,
         slots = c(number = <span style="color:#a31515">&#39;matrix&#39;</span>,
                   id = <span style="color:#a31515">&#39;character&#39;</span>,
                   time = <span style="color:#a31515">&#39;matrix&#39;</span>))
setIs(class1 = <span style="color:#a31515">&#39;trickNum&#39;</span>,
      class2 = <span style="color:#a31515">&#39;trickNumMat&#39;</span>,
      coerce = function(from) {
        toObj &lt;- new(<span style="color:#a31515">&#39;trickNumMat&#39;</span>,
                     number = as.matrix(from@number),
                     id = from@id,
                     time = from@time)
        return(toObj)
      },
      replace = function(from, value) {
        from@number = as.numeric(value@number)
        from@id = value@id
        from@time = value@time

        return(from)
      })
as(tn1, <span style="color:#a31515">&#39;trickNumMat&#39;</span>)
tnm1 &lt;- new(<span style="color:#a31515">&#39;trickNumMat&#39;</span>,
            number = matrix(rnorm(1:9), nrow = 3),
            id = <span style="color:#00f">LETTERS</span>[1:3],
            time = matrix(1:9, ncol = 3))
as(tn1, <span style="color:#a31515">&#39;trickNumMat&#39;</span>) &lt;- tnm1</code></pre></div>
<h3 id="5-2-虚类">5.2 虚类</h3>

<p>S4允许创建一个称为“虚类”的类。对于虚类，可以构建方法，可以创建子类，但是不能创造一个属于虚类的对象。虚类是为了解决“交集”的问题，即创建的多个新类中可能含有共同的slots。因此，将这些共同的slots处理成虚类，之后建立属于虚类的方法。这样，虚类下属的子类就能顺利继承。创建方法：第一种，<code>setClass()</code>函数的变量<code>contains</code>中加入<code>VIRTUAL</code>；第二种，<code>setClass()</code>函数只含有变量<code>Class</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">setClass(Class = <span style="color:#a31515">&#39;trickVirtual&#39;</span>,
         contains = c(id = <span style="color:#a31515">&#39;character&#39;</span>, <span style="color:#a31515">&#39;VIRTUAL&#39;</span>))
setClass(Class = <span style="color:#a31515">&#39;trickA&#39;</span>,
         contains = <span style="color:#a31515">&#39;trickVirtual&#39;</span>,
         slots = c(number = <span style="color:#a31515">&#39;numeric&#39;</span>))
setClass(Class = <span style="color:#a31515">&#39;trickB&#39;</span>,
         contains = <span style="color:#a31515">&#39;trickVirtual&#39;</span>,
         slots = c(log = <span style="color:#a31515">&#39;logical&#39;</span>))
getClass(<span style="color:#a31515">&#39;trickVirtual&#39;</span>)

setClass(Class = <span style="color:#a31515">&#39;testVirtual&#39;</span>)
getClass(<span style="color:#a31515">&#39;testVirtual&#39;</span>)</code></pre></div>
<h3 id="5-3-类群">5.3 类群</h3>

<p>类群是为了解决“并集”的问题，即把功能相似的类合成一个“类群”，每次使用时只用其中的一个。因此，创建的“类群”是一个父类。使用<code>isClassUnion(Class)</code>检验某个类是否为类群，使用<code>setClassUnion(name, members, where)</code>创建类群。在使用类群时，默认使用的是第一个定义的类。每一个类群是一个虚类。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">setClassUnion(name, members, where)</pre></div>
<blockquote>
<ul>
<li><p>name：字符串，类群名。</p></li>

<li><p>members：字符向量，一个或多个已定义的类。可以后续使用<code>setIs()</code>向类群中添加已定义的类。</p></li>

<li><p>where：设定环境。</p></li>
</ul>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r">setClassUnion(<span style="color:#a31515">&#34;trickUnion&#34;</span>, c(<span style="color:#a31515">&#34;logical&#34;</span>, <span style="color:#a31515">&#34;numeric&#34;</span>))
setClass(<span style="color:#a31515">&#34;trickUA&#34;</span>, contains = <span style="color:#a31515">&#39;trickUnion&#39;</span>, slots = c(id = <span style="color:#a31515">&#39;numeric&#39;</span>))
new(<span style="color:#a31515">&#39;trickUA&#39;</span>, 1:10, id = 1)
getClass(<span style="color:#a31515">&#39;trickUnion&#39;</span>)</code></pre></div>
<h2 id="6-建立对象注意事项">6. 建立对象注意事项</h2>

<ol>
<li><p>把所有对象写入一个文件<code>AllClass.R</code>，所有泛函写入<code>AllGeneric.R</code>。</p></li>

<li><p><code>setClass()</code>建立一个类，同时添加<code>validity</code>验证。</p></li>

<li><p>自定义<code>initialize()</code>（可选，建议使用默认设置）。</p></li>

<li><p>自定义构造函数，比如类似类名，<code>MyClass &lt;- function(slot1, ...){new('myClass', slot1 = slot1, ...)}</code>（可选，建议把<code>initialize()</code>内容放入）。</p></li>

<li><p>自定义<code>show()</code>，用于合理展示类。例如，一个大的矩阵，可以只展示一部分。而<code>print()</code>用于展示类的全部信息。</p></li>

<li><p>修改slot后，对返回的对象进行<code>validObject()</code>检查。</p></li>
</ol>

<h3 id="参考资料">参考资料</h3>

<ol>
<li><p><a href="https://cran.r-project.org/doc/contrib/Genolini-S4tutorialV0-5en.pdf">A (Not So) Short Introduction to S4</a>：详细的S4介绍。</p></li>

<li><p><a href="http://adv-r.had.co.nz/S4.html">Advance R &ndash; S4</a></p></li>

<li><p><a href="https://www.bioconductor.org/help/course-materials/2010/AdvancedR/S4InBioconductor.pdf">S4 System Development in Bioconductor</a></p></li>

<li><p><a href="https://www.crcpress.com/R-Programming-for-Bioinformatics/Gentleman/p/book/9781420063677">R Programming for Bioinformatics</a></p></li>
</ol>

<h3 id="更新记录">更新记录</h3>

<p>2017年9月7日</p>

		</div>

		<div class="post-tags">
			
				
					<nav class="nav tags">
							<ul class="flat">
								
								<li><a href="/tags/r">R</a></li>
								
							</ul>
					</nav>
				
			
		</div></div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-53073828-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
