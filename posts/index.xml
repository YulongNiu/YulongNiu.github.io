<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yulong Niu</title>
    <link>https://YulongNiu.github.io/posts/</link>
    <description>Recent content in Posts on Yulong Niu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright notice</copyright>
    <lastBuildDate>Sun, 03 Nov 2019 16:46:02 +0100</lastBuildDate><atom:link href="https://YulongNiu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Hugo搭建博客</title>
      <link>https://YulongNiu.github.io/posts/2019-11-03-setup_hugo_blog/</link>
      <pubDate>Sun, 03 Nov 2019 16:46:02 +0100</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2019-11-03-setup_hugo_blog/</guid>
      <description>从Octopress迁移至Hugo，希望可以稳定地维持5年。
1. 安装 ## 安装hogu $ sudo dnf install hugo ## 创建个人博客目录 $ hugo new site HugoBlog $ cd HugoBlog ## 选择主题 $ cd themes $ git clone https://github.com/vividvilla/ezhil.git $ cd .. ## 启动hugo $ hugo server ## 启动hugo并预览博文 $ hugo server -D 2. 基本配置 2.1 配置主页 编辑模板HugoBlog/config.toml。
2.2 配置博文header 编辑HugoBlog/archetypes/default.md，例如：
--- title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; date: {{ .Date }} description: &amp;#34;&amp;#34; tags: [] disqus: false draft: true --- draft: true为私密博文，draft: false为公开博文。</description>
    </item>
    
    <item>
      <title>小的改进能提升文章审稿速度</title>
      <link>https://YulongNiu.github.io/posts/2019-05-04-small-changes-smooth-review/</link>
      <pubDate>Sat, 04 May 2019 16:03:35 +0200</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2019-05-04-small-changes-smooth-review/</guid>
      <description>我最近看到Nature的一篇报道，讲述一些小的改进能提升文章的审稿速度。内容包括了草稿排版、写作和图表等方面，简要摘录关键信息。尽管遵循这些建议不会增加或减少文章被接受的概率，但能更加清楚地向读者和审稿人展现自己文章的核心内容。
  草稿排版
  宽行间距和大号字体。单列排版时，推荐使用1.5倍行距，每行12-15个单词。
  连续行编号，方便审稿人指出问题所在位置。
  图和图例尽量靠近相关文字。
    写作
  避免主观词汇。审稿人通常反感主观词汇，例如：unprecedented、 paradigm shift、 amazing、 dramatic、 interesting、 remarkable等。
  减少使用缩写。当文中出现5次或以上时，再考虑使用缩写。但一些熟知的专业名词，例如DNA、RNA等要使用缩写。
  避免使用无方向性词汇，influence。应该明确指出怎样影响（增加或减少），最好能有具体的数值表述。例如，改变×××倍提高了×××产量等。
  避免在所有情况下都使用significant。因为signficant容易和统计检验混淆，应该使用具体数值描述影响。
  文章起一个陈述性的题目。避免使用暗示性、假设性的题目，而应该具体描述文章的发现。注意不要夸大结果或者模糊描述。“通过避免使用主观词汇、仔细描述文章真实而非潜在暗示的发现，应该能找到一个可读性高、信息量大、有趣的题目，从而不会夸大文章的发现”。
  摘要写法，Nature提供了一个模板。
    数据和图标
  定义不确定量（统计学）。在图例中描述error bar、盒箱图等不确定量的定义。
  使用统计检验。
  展示和提取潜在数据。例如使用散点图（小数据）、盒箱图/小提琴图（大数据）等、提交数据至数据库等。
  合理上色。避免使用彩虹图、使用ColorBrewer等更加友好的配色方案。比如一种diverge配色方案（热图），中间数据使用白色、两边渐进黄蓝强对比色。
  简化图。去除3D、阴影或不必要的颜色等。
  图例中添加小标题。
    参考资料   How small changes to a paper can help to smooth the review process</description>
    </item>
    
    <item>
      <title>DESeq2包的对比组设计</title>
      <link>https://YulongNiu.github.io/posts/2019-04-15-deseq2-design/</link>
      <pubDate>Mon, 15 Apr 2019 14:58:58 +0200</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2019-04-15-deseq2-design/</guid>
      <description>1. 两两比对 DataFrame with 12 rows and 2 columns condition genotype &amp;lt;factor&amp;gt; &amp;lt;factor&amp;gt; sample1 A I sample2 A I sample3 A I sample4 A II sample5 A II ... ... ... sample8 B I sample9 B I sample10 B II sample11 B II sample12 B II 组A vs. 组B。
dds &amp;lt;- makeExampleDESeqDataSet(n = 100, m = 12) dds$genotype &amp;lt;- factor(rep(rep(c(&amp;#39;I&amp;#39;, &amp;#39;II&amp;#39;), each=3), 2)) ## condition: A vs. B design(dds) &amp;lt;- ~ condition ddres &amp;lt;- DESeq(dds) res &amp;lt;- results(ddres, contrast = c(&amp;#39;condition&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;A&amp;#39;)) ## genotype I vs.</description>
    </item>
    
    <item>
      <title>R包dplyr使用集锦</title>
      <link>https://YulongNiu.github.io/posts/2018-11-26-r-dplyr/</link>
      <pubDate>Mon, 26 Nov 2018 16:31:58 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2018-11-26-r-dplyr/</guid>
      <description>1. 使用dplyr包的好处   大多数时间在操作tbl_df对象，而不是data.frame（特别是含有factor的data.frame）。
  与magrittr包的管道更好地结合。
  更丰富的列操作，例如mutate、select。group_by会节省很多for循环。
  2. 列操作   filter()：过滤列，需要输入一个逻辑向量。xor(x, y)x和y并集除去交集的部分。between(x, left, right)left &amp;lt;= x &amp;lt;= right。near(x, y)x和y在一定精度下相等，比==安全）。直接使用列名操作，例如year == 2018。多列操作相当于&amp;amp;。受group操作影响。返回一个空的表格，只保留列名，filter(x, FALSE)。
  arrange()：列排序（默认升序）。多列操作时，先排序第一个，再对第一个相等的排第二个。desc()降序排列。.by_group = FALSE控制是否需要按照group进行组内操作。
  select()：选择列，重新组合新的tbl_df。结合tidyselect包的starts_with()前缀、end_with()后缀、contains()部分字符串、matches()正则匹配、num_range类似V01和x02之类、everything()（剩余）所有的列、last_col(offset = n)倒数第n+1列（默认n为0）。select(Col1 = col1)更改col1列名为Col1，并只返回Col1列。
  rename(Col1 = col1)：返回全部列，但更改列名为Col1。不受group操作影响。setNames(...)不属于dplyr包，但能快速更改所有列命名。
  mutate()：增加列，返回原始对象和增加列，增加列放置最后。transmute()：只返回增加的列。受group操作影响。
  summerise()：聚合列，对某一列或多列进行聚合操作。比如，求均值、方差、极大/小值等。受group操作影响。
  filter()、arrange()、mutate()、select()、transmute()、rename()和summerise()：有_all()、_at()和_if()操作，分别表示对全部列、指定列（序号1:4和-1:-2）和满足条件的列操作。
   _at()使用contains()等函数时，.var参数需要处理为.var = vars(contains())的形式。
  参数中的.funs操作是一个匿名函数，例如.funs = funs(ifelse(x, ., NA))，.表示对应的列。同时，.funs可以有多个操作(同时赋值列名)，比如.funs = funs(repNA = ifelse(x, .</description>
    </item>
    
    <item>
      <title>R和Rcpp的性能监测</title>
      <link>https://YulongNiu.github.io/posts/2018-10-03-profile-r-and-rcpp/</link>
      <pubDate>Wed, 03 Oct 2018 19:38:37 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2018-10-03-profile-r-and-rcpp/</guid>
      <description>1. R性能检测 直接使用profvis包即可，例如示例。
2. Rcpp性能检测 2.1 安装依赖软件 $ sudo dnf install gperftools-devel google-perftools graphviz ghostscript kcachegrind 2.2 编译 在包（包名称为Mypkg）目录src建立如下文件：
#include &amp;lt;Rcpp.h&amp;gt;#include &amp;lt;gperftools/profiler.h&amp;gt; using namespace Rcpp; // [[Rcpp::export]] SEXP start_profiler(SEXP str) { ProfilerStart(as&amp;lt;const char*&amp;gt;(str)); return R_NilValue; } // [[Rcpp::export]] SEXP stop_profiler() { ProfilerStop(); return R_NilValue; } 包目录src的Makevars文件中添加-lprofile选项，例如PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS) -lprofiler。之后，安装包，并重新载入。
2.3 调试 使用方法为：
Mypkg:::start_profiler(&amp;#34;/tmp/profile.out&amp;#34;) run_cpp_codes() Mypkg:::stop_profiler() 查看profile结果：
## text pprof --text src/Mypkg.so /tmp/profile.out ## pdf pprof --pdf src/Mypkg.so /tmp/profile.out &amp;gt; profile.</description>
    </item>
    
    <item>
      <title>使用RcppParallel并行计算</title>
      <link>https://YulongNiu.github.io/posts/2018-07-19-rcppparallel-test/</link>
      <pubDate>Thu, 19 Jul 2018 22:19:24 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2018-07-19-rcppparallel-test/</guid>
      <description>在之前的博文中，我详细讨论了使用多种R包实现并行计算。其中，提到一个非常重要的问题：
当循环数很大时（1万以上），`foreach`会变得非常慢。  这个问题在Florian Privé的A guide to parallelism in R中也提到，解释是foreach每次只合并100个循环结果。
1. 测试 我尝试使用RcppParallel包调用C++的并行方法。结论是：在循环数很大时，RcppParallel包提供的并行方法优于foreach。
一个简单的测试场景：对一个数值向量的每个元素做平方根运算，结果按原始顺序返回。在Gist1和Gist2中，分别实现了：
  SqrtR：用循环非并行操作每个元素。这种方法在R语言编程中不推荐，而应该尽量“向量化”操作。
  SqrtRforeach：foreach并行版本。
  SqrtRParSapply: parSapply并行版本。
  SqrtCpp：C++非并行版本。
  SqrtCppPara：RcppParallel包的C++并行版本。
  sqrt：R内置的向量化方法，C非并行版本。
  首先，比较5种实现效率，并行计算调用8个线程（Intel i7-4790 CPU@3.6GHz）。测试结果显示SqrtRPara（使用foreach）和非向量化的R版本SqrtR效率较低。
tmp1 &amp;lt;- runif(10e3) all.equal(SqrtCpp(tmp1), sqrt(tmp1), SqrtR(tmp1), SqrtRforeach(tmp1), SqrtRParSapply(tmp1), SqrtCppPara(tmp1)) ## TRUE microbenchmark( SqrtCpp(tmp1), sqrt(tmp1), SqrtR(tmp1), SqrtRforeach(tmp1), SqrtRParSapply(tmp1), SqrtCppPara(tmp1)) ## Unit: microseconds ## expr min lq mean median ## SqrtCpp(tmp1) 56.295 72.648 9.338755e+01 82.</description>
    </item>
    
    <item>
      <title>通过RNA-Seq评估基因表达量的模型</title>
      <link>https://YulongNiu.github.io/posts/2018-02-17-estimate-rna-seq/</link>
      <pubDate>Sat, 17 Feb 2018 18:23:29 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2018-02-17-estimate-rna-seq/</guid>
      <description>$$ \newcommand{\tildel}{\widetilde{l_t}} $$
$$ \newcommand{\P}{\mathrm{P}} $$
$$ \DeclareMathOperator*{\argmax}{arg,max} $$
本文基于参考资料1，展示RNA-Seq在评估基因表达量模型的细节。
1. 符号表示 $K$个长度为$l_i$的转录序列$t_i$，构成转录本的集合$T=\{t_1, t_2, \dots, t_K\}$。单个转录组中，每个转录序列$t_i$有$c_i$个拷贝数，全部转录序列的总拷贝数为$M$。单个转录序列的相对丰度为$\rho_k=\frac{c_k}{\sum\limits_{t \in T} c_t} = \frac{c_k}{M}$，易得$\sum\limits_{k=1}^K \rho_k=1$。
单个转录组中，全部转录片段构成集合$F=\{f_1, f_2, \dots, f_N\}$，总转录片段数目为$N=|F|$。比对到的转录序列$t_i$上的转录片段，构成集合$F_t \in F$，对应的转录片段数目为$X_t=|F_t|$。
2. 简单模型 简单模型为：单端RNA-Seq，每一个read只比对到一个转录序列上，且每个read的长度都为定值$m$。对于转录序列$t_i$，从5&#39;到3&#39;一共可能比对上的read数目为$\tildel = l_i - m + 1$。建立模型的思路是：当给定一个read，它会被比对到某个转录序列的某个位置是一个随机事件。通过实际观测（即将read比对到转录序列），进而估计未知参数$\rho = \{\rho_1, \rho_2, \dots, \rho_K\}$。
通过read序列比对，可得观测数据类似如下矩阵。每一行表示某个read是否比对到某个转录序列的某个位置，行和为1。$1$表示read比对到对应转录序列上，$0$表示没有比对到对应转录序列。
$$ \left[ \begin{matrix} 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1 \newline 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \newline \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \newline 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1 \newline \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>Bray-Curtis distance解释</title>
      <link>https://YulongNiu.github.io/posts/2017-10-24-bray-curtis-distance/</link>
      <pubDate>Tue, 24 Oct 2017 12:26:00 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-10-24-bray-curtis-distance/</guid>
      <description>$$ \newcommand{\sumup}[1] {\sum\limits_{i=1}^{n} #1} $$
Bray-Curtis distance（BCD）的定义为：
$$ \begin{align} \begin{split} BCD(X, Y) = \frac{\sumup{|x_i - y_j|}}{\sumup{x_i} + \sumup{y_i}} \end{split} \label{eq:1} \end{align} $$
其中，$X$和$Y$分别为长度为$n$的数值向量。根据$\eqref{eq:1}$可以得出：$BCD$的取值范围为$[0, 1]$；当$X$和$Y$完全相同时，$BCD$为0；反之，$BCD$为1。
同样，Bray-Curtis similarity（BCS）或Bray-Curtis index为：
$$ \begin{align} \begin{split} BCS(X, Y) = 1 - BCD(X, Y) \end{split} \label{eq:2} \end{align} $$
参考资料  Chapter 6 Measures of distance and correlation between variables  更新记录 2017年10月22日</description>
    </item>
    
    <item>
      <title>Normalized Google distance解释</title>
      <link>https://YulongNiu.github.io/posts/2017-10-22-google-distance/</link>
      <pubDate>Sun, 22 Oct 2017 21:35:30 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-10-22-google-distance/</guid>
      <description>$$ \newcommand{\sumup}[1] {\sum\limits_{i=1}^{n} #1} $$
本文尝试探索Normalized Google distance（简称NGD）的定义和拓展应用。
1. NGD原始定义 维基百科的定义为：
$$ \begin{align} \begin{split} NGD(x, y) = \frac{\max{\log f(x), \log f(y)} - \log f(x, y)}{\log N - \min{\log f(x), \log f(y)}} \end{split} \label{eq:1} \end{align} $$
其中，$f(x)$和$f(y)$分别为关键词$x$和$y$出现的次数，$f(x,y)$为$x$和$y$同时出现的次数，$N$为全部搜索单词数目。根据$\eqref{eq:1}$可以得出：如果$x$和$y$几乎总是同时出现时，$NGD$趋近于$0$；如果$x$和$y$出现的次数很少，即$\log f(x,y)$趋近于负无穷，则$NGD$可能大于$1$。
2. NGD定义延伸 Choi and Rashid在2008年的文章提出一种针对向量的$NGD$定义：
$$ \begin{align} \begin{split} NGD(X, Y) &amp;amp;= \frac{\max\left\{\sumup{x_i}, \sumup{y_i}\right\} - \sumup{\min(x_i, y_i)}}{\sumup{x_i} + \sumup{y_i} - \sumup{\min(x_i, y_i)}} \newline &amp;amp;= \frac{\max\left\{\sumup{x_i}, \sumup{y_i}\right\} - \sumup{\min(x_i, y_i)}}{\max\left\{\sumup{x_i}, \sumup{y_i}\right\}} \end{split} \label{eq:2} \end{align} $$</description>
    </item>
    
    <item>
      <title>最大熵模型</title>
      <link>https://YulongNiu.github.io/posts/2017-10-16-max-entropy/</link>
      <pubDate>Mon, 16 Oct 2017 13:16:12 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-10-16-max-entropy/</guid>
      <description>1. 熵和条件熵 对于随机变量$X$，熵为：
$$ \begin{align} \begin{split} H(X) = -\sum_{x \in X}p(x)\log{p(x)} \end{split} \label{eq:1} \end{align} $$
其中：
$$ \begin{align} \begin{split} \sum_{x \in X}p(x) = 1 \end{split} \label{eq:2} \end{align} $$
同样道理，对于任意随机变量$X$和$Y$，联合熵为：
$$ \begin{align} \begin{split} H(X,Y) = -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)} \end{split} \label{eq:3} \end{align} $$
基于$X$的$Y$的熵为条件熵：
$$ \begin{align} \begin{split} H(Y|X) &amp;amp;= H(X, Y) - H(X) \newline &amp;amp;= -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)} + \sum_{x \in X}p(x)\log{p(x)} \newline &amp;amp;= -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)} + \sum_{x \in X, y \in Y}p(x, y)\log{p(x)} \newline &amp;amp;= -\sum_{x \in X, y \in Y}p(x, y)\log \frac{p(x, y)}{p(x)} \end{split} \label{eq:4} \end{align} $$</description>
    </item>
    
    <item>
      <title>朴素贝叶斯分类器应用于二元数据类型</title>
      <link>https://YulongNiu.github.io/posts/2017-10-15-naive-bayes-binary-multinomial/</link>
      <pubDate>Sun, 15 Oct 2017 17:38:16 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-10-15-naive-bayes-binary-multinomial/</guid>
      <description>1. 贝叶斯定理 已知事件$A$和$B$，则条件概率为：
$$ \begin{align} \begin{split} P(A | B) &amp;amp;= \frac{P(A,B)}{P(B)} \newline P(B | A) &amp;amp;= \frac{P(A,B)}{P(A)} \end{split} \label{eq:1} \end{align} $$
可以推导出：
$$ \begin{align} P(B|A) = \frac{P(A|B)P(B)}{P(A)} \label{eq:2} \end{align} $$
2. 分类器简介 朴素贝叶斯分类器（Naive Bayes classifier）是一种简单、有效的分类器，其难点在于估算条件概率。比如，一个数据集拥有$N$个相互独立的特征，$C$个分组，对于$C_j$条件概率模型为：
$$ \begin{align} \begin{split} p(C_j|F_1,\cdots,F_n) &amp;amp;= \frac{p(F_1,\cdots,F_n|C_j)p(C_j)}{p(F_1,\cdots,F_n)} \newline &amp;amp;= p(F_1|C_j) \cdots p(F_n|C_j)p(C_j)(1/p(F_1,\cdots,F_n)) \end{split} \label{eq:3} \end{align} $$
由于$1/p(F_1,\cdots,F_n)$在不同分组中为定值，因此：
$$ \begin{align} \begin{split} p(C_j|F_1,\cdots,F_n) &amp;amp;\propto p(C_j)\prod_{i=1}^{N}p(F_i|C_j) \end{split} \label{eq:4} \end{align} $$
其中，$p(C_j)$通常容易求得，即$C_j$分组在测试数据集中出现的频率。而$p(F_i\ \vert C_j)$则根据不同的测试数据类型，有不同的估计值。
以下讨论两种二元数据类型，例如某个数据集有三种特征量：
$$ F = \left[ \begin{array}{f} F_1 \newline F_2 \newline F_3 \end{array} \right] $$</description>
    </item>
    
    <item>
      <title>Shadowsocks设置推荐</title>
      <link>https://YulongNiu.github.io/posts/2017-06-14-shadowsocks-setup/</link>
      <pubDate>Wed, 14 Jun 2017 23:49:13 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-06-14-shadowsocks-setup/</guid>
      <description>1. Shadowsocks客户端 Shadowsocks在主流平台上都有客户端，下载直接使用即可。对于Linux平台，可能还需要在Chrome浏览器中安装SwitchyOmega插件。
2. 谷歌设置 进入网址，设置自己喜欢的语言，之后重启即可。
3. 自己配置Shadowsocks 3.1 软件准备 参考shadowsocks网站安装。
$ sudo dnf copr enable librehat/shadowsocks $ sudo dnf update $ sudo dnf install shadowsocks-libev 3.2 配置文件 文件位置/etc/shadowsocks-libev/config.json，设置模板：
{ &amp;#34;server&amp;#34;:&amp;#34;0.0.0.0&amp;#34;, &amp;#34;port_password&amp;#34;:{ &amp;#34;8381&amp;#34;:&amp;#34;******&amp;#34;, &amp;#34;8382&amp;#34;:&amp;#34;******&amp;#34; }, &amp;#34;timeout&amp;#34;:600, &amp;#34;method&amp;#34;:&amp;#34;aes-256-cfb&amp;#34; } 3.3 启动 $ sudo ss-manager -c /etc/shadowsocks-libev/config.json --manager-address 127.0.0.1:8000 -u config.json 4. 使用TCP BBR加速 $ sudo echo &amp;#34;net.core.default_qdisc=fq&amp;#34; &amp;gt;&amp;gt; /etc/sysctl.conf $ sudo echo &amp;#34;net.ipv4.tcp_congestion_control=bbr&amp;#34; &amp;gt;&amp;gt; /etc/sysctl.conf $ sudo sysctl -p $ sudo sysctl net.</description>
    </item>
    
    <item>
      <title>探索Java基本类型的二进制表示</title>
      <link>https://YulongNiu.github.io/posts/2017-05-16-java-binary/</link>
      <pubDate>Tue, 16 May 2017 20:17:46 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2017-05-16-java-binary/</guid>
      <description>1. 基本数据类型 Java有八种基本数据类型（primitive data type），分别是boolean、char、byte、short、int、long、float和double，所占用的比特数如下表所示。
  Data type Bit Range     boolean not precisely defined True or false   char unsigned 16 $2^{16}$   byte signed 8 $-2^{7}$ ~ $2^7-1$   short signed 16 $-2^{15}$ ~ $2^{15}-1$   int signed 32 $-2^{31}$ ~ $2^{31}-1$   long signed 64 $-2^{63}$ ~ $2^{63}-1$   float signed 32 $\pm (1-2^{-24}) * 2^{128}$ 精度$2^{-126}$    2.</description>
    </item>
    
    <item>
      <title>两个git的rebase命令应用</title>
      <link>https://YulongNiu.github.io/posts/2016-11-11-git-rebase-examples/</link>
      <pubDate>Fri, 11 Nov 2016 16:24:39 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-11-11-git-rebase-examples/</guid>
      <description>介绍两个git rebase的应用场景，一个是合并commits记录，另一个是贡献代码。
1. 合并commit记录 假定有多条commits，按照离当前时间从近至远依次为：c1、b2、b1和a1。希望合并c1、b2和b1，即只保留c1和a1。操作流程如下：
 打开交互式rebase  $ git rebase -i sha1id-of-a1  标记合并commits  弹出的文本编辑器初始可能为：
pick sha1id-of-c1 c1 pick sha1id-of-b2 b2 pick sha1id-of-b1 b1 ... 修改为：
pick sha1id-of-c1 c1 squash sha1id-of-b2 b2 squash sha1id-of-b1 b1 ...  记录合并commits  在弹出的文本编辑器中标记和注释commits
 提交远程  由于本地和远程记录不一致，需要强制合并。
$ git push -f origin mybranch 2. 贡献代码  Fork项目  Fork在GitHub对应的项目（famous/project，master分支）至自己账户（my/project），克隆至本地并添加远程地址：
$ git clone https://github.com/my/project.git $ git remote add upstream https://github.com/famous/project.git  建立分支并提交修改  $ git checkout -b devbranch $ git commit -a -m &amp;#39;these commits&amp;#39; $ git push origin devbranch  获取和合并最新远程修改  $ git checkout master $ git pull upstream master $ git checkout devbranch $ git rebase master ## compare and merge the latest commits $ git rebase --continue ## force push $ git push -f origin devbranch  发起pull request。  参考资料   合并分支</description>
    </item>
    
    <item>
      <title>命令行使用Google Drive</title>
      <link>https://YulongNiu.github.io/posts/2016-10-21-linux-sync-google-drive/</link>
      <pubDate>Fri, 21 Oct 2016 18:24:31 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-10-21-linux-sync-google-drive/</guid>
      <description>推荐使用更更方便的VGrive。
推荐使用更方便的ODrive。
本文简单介绍gdrive，它是一个跨多个平台软件，提供命令行操作Google Drive。同类软件还有drive和overGrive（Linux下Google Drive界面客户端）。
基本思路：对每一个上传至Google Drive的文件或文件夹都分配一个Id，所以云端操作需要指定Id。
突出优点：自动同步，比较云端和本地文件后，决定上传、删除或者替换；同步加入版本控制，可以下载和删除不同版本文件。
1. 初始化 下载系统对应版本，执行gdrive about，根据提示设置。
2. 查找 查找规则
## 查找所有文件夹，不包括垃圾箱，所有者为自己 $ gdrive list --query &amp;#34;mimeType = &amp;#39;application/vnd.google-apps.folder&amp;#39; and trashed = false and &amp;#39;me&amp;#39; in owners&amp;#34; ## 加入上层目录Id gdrive list --query &amp;#34;mimeType = &amp;#39;application/vnd.google-apps.folder&amp;#39; and trashed = false and &amp;#39;me&amp;#39; in owners and &amp;#39;YUlPWWdLcy1mX2c&amp;#39; in parents&amp;#34; ## 查询信息 gdrive info YUlPWWdLcy1mX2c 3. 建立和删除 ## 建立文件夹 $ gdrive mkdir newFolder ## 建立下一层文件夹，-p指定上层目录Id $ gdrive mkdir -p M1h4M1dGYUhpSFE newFolder ## 删除文件（文件Id，非名称） $ gdrive delete 0BzTeuubJesi ## 删除文件夹（文件Id，非名称） $ gdrive delete -r 0BzTeuubJesi 4.</description>
    </item>
    
    <item>
      <title>如何在Nature communications上发表文章</title>
      <link>https://YulongNiu.github.io/posts/2016-09-22-how-to-publish-in-nc/</link>
      <pubDate>Thu, 22 Sep 2016 16:25:13 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-09-22-how-to-publish-in-nc/</guid>
      <description>我最近看到一个幻灯片，主要讲了在Nature Communications（NC）上发表文章的建议，作者是NC的副主编Nicky Dean。整个幻灯片一种轻松幽默的口吻，讲述了投稿和发表文章过程的各种问题，并提出了针对性建议，值得推荐。以下记录一些关键信息。
投稿前注意事项   Nature杂志（可能此处也指NC）只考虑有重大创新（conceptually novel）的工作，而不是补充完善数据类型研究。
  不要有快速发表的想法。
  不介意会议报告或者预印服务网站发表。
  介意发表在出版的会议录（conference proceedings）或者其他大规模传播的媒介上。
  准备充分   问问自己这个研究适合于本领域的哪些地方？这个研究是否有显著的进步？
  从一开始就好好准备文稿，比如文稿有清晰的结构、容易理解，并且能够传达出最主要信息。
  阅读《作者须知》，使得文稿符合杂志的要求。
  准备cover letters   解释工作的创新，但不要过了。
  推荐审稿人，但不能都是自己的熟人。
  可以推荐需要屏蔽的审稿人。
  明确一切相关的正在发表或者已经投稿的文章。
  文章要素   解释清楚研究领域背景，即回答“我们为什么要重视这项研究？”
  清晰地描述做了什么工作。
  连接研究内容和领域背景，以说服别人这项研究确实有重大突破。
  发表文章的目的是为了更有效地交流，而不是显示自己有聪明!
  NC编辑审核常规要点   研究的创新性。
  支持数据。</description>
    </item>
    
    <item>
      <title>HISAT2使用问答</title>
      <link>https://YulongNiu.github.io/posts/2016-09-10-hisat2-faq/</link>
      <pubDate>Sat, 10 Sep 2016 16:32:47 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-09-10-hisat2-faq/</guid>
      <description>HISAT2是一款用于“对应（map）”二代测序数据（全基因组、转录组和外显子组）至目标基因组的工具，用来替代HISAT和TopHat2。本文汇集一些使用HISAT2的常见问题问答。
如何解读HISAT2的输出统计？ 一个常见的双端测序样本HISAT2输出统计：
10000 reads; of these: 10000 (100.00%) were paired; of these: 650 (6.50%) aligned concordantly 0 times 8823 (88.23%) aligned concordantly exactly 1 time 527 (5.27%) aligned concordantly &amp;gt;1 times ---- 650 pairs aligned concordantly 0 times; of these: 34 (5.23%) aligned discordantly 1 time ---- 616 pairs aligned 0 times concordantly or discordantly; of these: 1232 mates make up the pairs; of these: 660 (53.57%) aligned 0 times 571 (46.</description>
    </item>
    
    <item>
      <title>常用参考基因组下载地址</title>
      <link>https://YulongNiu.github.io/posts/2016-09-10-reference-genome-location/</link>
      <pubDate>Sat, 10 Sep 2016 13:17:00 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-09-10-reference-genome-location/</guid>
      <description>本文收集了一些常用参考基因组的下载网址和补充说明。
  NCBI genome
  Ensembl FTP
  UCSC FTP：cytoband文件可能含有gneg等标识，其中acen表示着丝粒区域、stalk表示近端着丝粒区域、gvar表示异染色质，例如臂间或端粒区域。
  GENCODE：只有人和大鼠，注释较好。
  iGenomes：部分模式生物bowtie、bowtie2和BWA索引基因组。
  HISAT2：部分模式生物HISAT2索引基因组。
  更新记录 2018年8月6日</description>
    </item>
    
    <item>
      <title>为什么不推荐在R语言中随意按照下标操作矩阵</title>
      <link>https://YulongNiu.github.io/posts/2016-07-21-subset-matrix-in-r/</link>
      <pubDate>Thu, 21 Jul 2016 19:35:29 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-07-21-subset-matrix-in-r/</guid>
      <description>这篇博文的目的是展示R语言中下标操作矩阵的潜在问题。R语言提供了多种方法提取一个矩阵的单个或者部分元素，不同方法对应的效率在Hadley Wickham的Advance R中已有讨论。这些方法中，使用最广泛的是通过下标（行或者列）取值，即操作符[。然而，这种方法存在潜在问题，即内存中会拷贝原始对象。
举例：首先建立一个矩阵，之后取这个矩阵除了第一行之外的部分，接下来操作这个部分矩阵。
## step1: build matrix n &amp;lt;- 8000 tmp1 &amp;lt;- matrix(rnorm(n * n), nrow = n, ncol = n) gc() ## step2: manipulate a subset of matrix sink(&amp;#39;/dev/null&amp;#39;) apply(tmp1[2:n, ], 1, function(x) x[1]) sink() ## step3: garbage collection gc() 内存使用情况如下：
  标记1内存上升，因为建立了tmp1的矩阵；
  标记2内存再次上升，主要因为使用下标取矩阵操作，tmp1[2:n, ]；
  标记3内存下降，因为手动执行垃圾回收。
  可以明显看到内存中多余的垃圾对象。如果使用for循环形式，就可以有效避免内存对象拷贝。虽然，R在内存空间不足时，会自动执行gc()。但是，执行程序时，不能全指望自动垃圾回收，毕竟有时回收得并不及时，而新的对象又相继生成。这种情况下，内存空间不足就成为很严重的问题。
R版本3.3.1。
更新记录 2016年7月21日</description>
    </item>
    
    <item>
      <title>C语言指针记录</title>
      <link>https://YulongNiu.github.io/posts/2016-04-17-pointers-in-c/</link>
      <pubDate>Sun, 17 Apr 2016 22:42:25 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-04-17-pointers-in-c/</guid>
      <description>1. C语言指针基础 C语言的指针设计是一致和优雅的。C语言中“指针（pointer）”就是地址（所以不能用普通整数储存地址），“指针变量（pointer variable）”是存储地址的变量。一个指针变量，只能指向一个特定类型的变量，比如整数、浮点数、字符或者指针。
int tmp1 = 1, tmp2; /* &amp;#34;=&amp;#34; does not mean &amp;#34;assignment&amp;#34;, it just means &amp;#34;initiating&amp;#34; */ /* p is the address of tmp1, *p is equal to the value of tmp1*/ int *p = &amp;amp;tmp1; int *q; q = &amp;amp;tmp2; /* p points to tmp1, q points to tmp2, now the value of tmp2 is 1*/ *p = *q; /* p and q now both points to tmp1*/ q = p; 2.</description>
    </item>
    
    <item>
      <title>Docker使用记录</title>
      <link>https://YulongNiu.github.io/posts/2016-03-11-docker-use/</link>
      <pubDate>Fri, 11 Mar 2016 16:53:51 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-03-11-docker-use/</guid>
      <description>关于Docker的安装和使用，有详细的文档可供参考。本文收集一些有趣和重要的记录。
1. 普通用户权限执行Docker 创建docker用户组并添加普通用户。
$ sudo groupadd docker $ sudo usermod -aG docker myUserName 注销后，再次登录即可。
2. Docker命令集锦 # 测试Docker $ docker run hello-world # Docker镜象列表 $ docker image ls $ docker image ls --digests # Docker容器列表 $ docker container ls $ docker container ls --all # 列出容器 $ docker ps $ docker ps -al # 终止所有容器 $ docker stop $(docker ps -aq) # 删除镜像 $ docker image rm myImg@sha256:xxx ## 删除虚悬镜像 $ docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1 }&amp;#39;|xargs docker stop $ docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1 }&amp;#39;|xargs docker rm $ docker images|grep none|awk &amp;#39;{print $3 }&amp;#39;|xargs docker rmi 3.</description>
    </item>
    
    <item>
      <title>Rcpp操作矩阵和向量集锦</title>
      <link>https://YulongNiu.github.io/posts/2016-01-07-rcpp-matrix/</link>
      <pubDate>Thu, 07 Jan 2016 20:50:41 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2016-01-07-rcpp-matrix/</guid>
      <description>收集和记录Rcpp或者RcppArmadillo操作矩阵和向量。
1. Rcpp  可以使用逻辑下标（LogicalVector）对向量和列表取值。  2. RcppArmadillo 基本类型是mat、vec（colvec）和rowvec。
  属性
 对于矩阵，行数：m.n_rows;；列数：m.n_cols;；维度：m.size();或size(m);。对于向量，元素数：v.n_elem;。    特殊向量或矩阵
  全是1ones&amp;lt;mat&amp;gt;(3, 4);/vec(10, fill::ones);/；全是0zeros&amp;lt;vec&amp;gt;(10);/mat(3, 4, fill::zeros);；全是某个数mat a(4, 5); a.fill(123.4);。
  连续向量，规定长度linspace&amp;lt;vec&amp;gt;(0, 5, 6);；连续向量，规定间距regspace&amp;lt;vec&amp;gt;(0, 2, 9);。
    取值
  对于向量，连续取值：v.subvec(1stIdx, lastIdx);；非连续，可以考虑使用find()函数，比如：v.elem(find(v &amp;gt; 0));。
  对于矩阵，连续取值：m.col(Idx);/m.row(Idx);/m.cols(Idx);/m.rows(Idx);/m.submat(1stRowIdx, lastRowIdx, 1stColIdx, lastColIdx);；非连续，m.submat(vecRowIdx, vecColIdx);。
    Rcpp矩阵转换为RcppArmadillo矩阵，可以避免拷贝矩阵，以提升效率，mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false){:.language-cpp}。同样道理，可以转化向量。例如：
  arma::mat TransferMatArma(Rcpp::NumericMatrix x, Rcpp::NumericVector y) { mat tx(x.</description>
    </item>
    
    <item>
      <title>XML中XPath规则总结</title>
      <link>https://YulongNiu.github.io/posts/2015-10-25-xpath-xml/</link>
      <pubDate>Sun, 25 Oct 2015 19:05:33 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-10-25-xpath-xml/</guid>
      <description>XPath提供了一种对XML节点、节点属性和内容快速查询的规则。在各种编程语言中都有实现，比如C语言的libxml2和对应的R包 xml2。
1. 查询规则 XPath查询集中在三个对象：节点、节点属性和节点内容。
1.1 选择节点   /nodeA/nodeB：nodeA为根节点，nodeA下的所有nodeB节点；等价于nodeB。
  //nodeB：所有nodeB节点，在R包xml2中（比如函数xml_find_all()），//nodeB搜索范围是整个文档，忽略当前节点；而.//nodeB搜索范围是当前节点之下。
  //nodeB[1]：所有nodeB节点的第一个；//nodeB[last()-1]：所有nodeB节点的倒数第二个；nodeA/nodeB[position()&amp;lt;3]:当前nodeA节点，其下所有nodeB子节点的前两个。
  /nodeA/*：nodeA为根节点，nodeA下的所有节点；/*/*/nodeC：所有拥有两个父节点的nodeC节点；//*：所有节点。
  //*[count(nodeD)=3]：含有3个nodeD子节点的节点；//*[count(*)=2]：含有任意2个子节点的节点。
  //*[name()=&#39;nodeB&#39;]：所有名称为“nodeB”的节点，等价于//nodeB；//*[starts-with(name(),&#39;N&#39;)]：所有名称以“N”开头的节点；//*[contains(name(),&#39;N&#39;)]：所有名称中含有“N”的节点；//*[string-length(name()) = 3]：所有名称的字符串长度等于3的节点。
  //nodeA | //nodeB：所有nodeA，以及nodeB的节点，多个搜索条件合并，搜索添加没有限制。
  1.2 选择节点属性   //@attr1：所有拥有attr1的属性，注意：返回的不是节点，而是类此attr1=text1的属性；//node1/@attr1：所有node1带有的attr1属性；//nodeB[@attr1]：所有拥有“attr1”属性的nodeB节点；//nodeB[@attr1=&#39;test1&#39;]：所有拥有“attr1”属性为“test1”的nodeB节点；//nodeB[normalize-space(@attr1)=&#39;test1&#39;]：所有拥有attr1属性为“test1”（属性去除字符串前后空格，内部连续空格替换为一个空格）的nodeB节点。
  //node1[@*]：所有node1带有任意属性的节点；//node1[not(@*)]：所有node1不带属性的节点；//node1[contains(@attr1, &#39;N&#39;)]：带有“attr1”属性的node1节点，“attr1”属性中含有“N”。
  //node1[TEST1][TEST2]：多个属性形选择可以首位相接，依次判断是否为真。TEST1和TEST2同时为真，返回选择结果。//nodeA[nodeB/@attr1=&#39;test1&#39;]：选择所有nodeA节点，这些nodeA节点拥有nodeB子节点且属性“attr1”为“test1”。//nodeC[@attr1=&#39;test1&#39;][../nodeB/@attr2=&#39;test2&#39;]：选择所有拥有“attr1”为“test1”的nodeC节点，而且这些nodeC节点有属性“attr2”为“test2”的nodeB父亲节点。
  1.3 选择节点内容   /nodeA/nodeB[nodeC&amp;gt;5]：nodeA为根节点，nodeA下的nodeB节点，而且这些nodeB节点必须有nodeC子节点，并且nodeC子节点内容大于5。
  /nodeA/nodeB[nodeC&amp;gt;5]/nodeD：nodeA为根节点，nodeA下的nodeB节点，而且这些nodeB节点必须有nodeC子节点，并且nodeC子节点内容大于5。
  //nodeC[.=5]：所有nodeC节点，其内容等于5。使用.代替自身。
  //nodeC/node()：选择所有nodeC节点下的所有点，包括节点下内容和子节点（距离最近，不包括子节点的子节点）。
  //nodeC/text()：选择所有nodeC节点下的内容。
  1.4 函数使用  //nodeC[contains(text(), &#39;test1&#39;)]：选择所有nodeC节点，而且nodeC节点下内容包括“test1”。  2.</description>
    </item>
    
    <item>
      <title>Spacemacs使用记录</title>
      <link>https://YulongNiu.github.io/posts/2015-09-30-spacemacs-tutorial/</link>
      <pubDate>Wed, 07 Oct 2015 22:09:31 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-09-30-spacemacs-tutorial/</guid>
      <description>Spacemacs结合了Vim和Emacs，而且定制了各种好用的设置，极大地减轻了Emacs的配置负担。推荐使用hybrid模式，这样浏览代码时可以使用Vim快捷键，进入Insert mode后使用Emacs快捷键。hybrid模式还有一个好处，编辑时方便汉字输入。Vim模式的先导键是SPC，在Emacs模式下是M-m。
1. Vim快捷键记录 在Spacemacs中SPC-h-T进入Emacs Evil快速入门。
1.1 移动   h：前
  j：上
  k：下
  l：后
  gg：
  文档开始位置。
  G：文档结束位置。
  :[number]：跳转到制定行。
    1.2 插入和替换   i：
  在光标前的位置，进入insert mode，进行编辑。
  ESC或者C-[退出insert mode。
    r：替换光标所在位置的单个字符。
  [number] d object：
  cw或ce：从光标处删除整个单词，并进入insert mode。
  c$：从光标处删除整行，并进入insert mode。
    1.</description>
    </item>
    
    <item>
      <title>Gibbs取样</title>
      <link>https://YulongNiu.github.io/posts/2015-10-03-gibbs-sampling/</link>
      <pubDate>Sat, 03 Oct 2015 14:37:08 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-10-03-gibbs-sampling/</guid>
      <description>$$ \newcommand{\md}{\mathrm{d}} $$
1. Gibbs取样简介 Gibbs取样的核心在于写出多元变量的联合分布，然后根据 $p(X | Y)=\frac{p(X, Y)}{p(Y)}$ 写出各个变量的条件分布，之后使用已有变量样本，依次“抽取-更新”迭代：
$$ \begin{align*} \begin{split} 第n次迭代，变量样本为: x^{(n)} = (x_1^{(n)}, x_2^{(n)}, \dots, x_k^{(n)})^T \newline p(x_1 | x_2^{(n)}, x_3^{(n)}, \dots, x_k^{(n)})抽取变量即为x_1^{(n+1)} \newline p(x_2 | x_1^{(n+1)}, x_3^{(n)}, \dots, x_k^{(n)})抽取变量即为x_2^{(n+1)} \newline &amp;amp; \vdots \newline p(x_k | x_1^{(n+1)}, x_2^{(n+1)}, \dots, x_{k-1}^{(n+1)})抽取变量即为x_k^{(n+1)} \newline 生成新样本: x^{(n+1)} = (x_1^{(n+1)}, x_2^{(n+1)}, \dots, x_k^{(n+1)})^T \end{split} \end{align*} $$
当抽取足够多次时，计算目标函数$f(x)$的均值：
$$ \begin{align*} \begin{split} f_{mn} = \frac{1}{n-m}\sum_{i = m+1}^{n}f(x^{(i)}) \end{split} \end{align*} $$
2. 结合图模型提高抽样效率 在实际应用中，可以结合概率图模型提高抽样效率。具体原理是：对于随机变量$x_1, x_2, \dots, x_n$，条件概率：</description>
    </item>
    
    <item>
      <title>一些共轭先验</title>
      <link>https://YulongNiu.github.io/posts/2015-08-02-conjugate-priors/</link>
      <pubDate>Sun, 02 Aug 2015 15:53:54 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-08-02-conjugate-priors/</guid>
      <description>$$ \newcommand{\md}{\mathrm{d}} $$
共轭先验（Conjugate prior）在贝叶斯估计中被广泛应用，本文尝试详细推理一些常见分布的共轭先验。
贝叶斯公式：
$$ \begin{align} \begin{split} f(\theta | x) &amp;amp;= \frac{f(\theta, x)}{f(x)} \newline &amp;amp;= \frac{f(x | \theta)f(\theta)}{\int f(x | \theta)f(\theta) \md \theta} \end{split} \label{eq:1} \end{align} $$
1. 离散分布 1.1 伯努利分布 伯努利分布（Bernoulli distribution）的概率质量函数为：
$$ \begin{align} \begin{split} f(k;p) = p^k (1-p)^{1-k} \quad \mathrm{for} \quad k \in (0, 1) \end{split} \label{eq:2} \end{align} $$
对于随机变量$X_i \in \{X_1, X_2, \dots, X_m\}$易得，$p$的极大似然估计（Maximum Likelihood Estimator, MLE）为$\hat{p}=\frac{\sum_{i=1}^{m}k_i}{m}$。
该分布的共轭先验为Beta分布$\mathrm{Beta}(\alpha, \beta)$，即对于随机变量$X_i$：
$$ \begin{align} \begin{split} f(p|X_i) &amp;amp;= \frac{p^{k_i} (1-p)^{1-k_i} \frac{1}{\mathrm{B}(\alpha, \beta)} p^{\alpha - 1} (1-p)^{\beta -1}}{f(X_i)} \newline &amp;amp;=\frac{\frac{1}{\mathrm{B}(\alpha, \beta)} p^{k_i+\alpha-1}(1-p)^{\beta - k_i}}{\int_0^1 \frac{1}{\mathrm{B}(\alpha, \beta)} p^{k_i+\alpha-1}(1-p)^{\beta - k_i} \md p} \newline &amp;amp;= \frac{p^{k_i+\alpha-1}(1-p)^{\beta - k_i}}{\mathrm{B}(k_i+\alpha, \beta+1 -k_i)} \newline &amp;amp;= \mathrm{Beta}(k_i+\alpha, \beta+1-k_i) \end{split} \label{eq:3} \end{align} $$</description>
    </item>
    
    <item>
      <title>PostgreSQL使用指南</title>
      <link>https://YulongNiu.github.io/posts/2015-07-29-postgresql-usage/</link>
      <pubDate>Wed, 29 Jul 2015 18:24:10 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-07-29-postgresql-usage/</guid>
      <description>1. 查询 -- 选取特定的一列或者多列 SELECT column1, column2 FROM dataset -- 选取全部列 SELECT * FROM dataset -- 去除重复，选取一列或多列中唯一元素 -- 如输入多列，则去除多列组合后的重复 SELECT DISTINCT column1, column2 FROM dataset -- 指定输出列数 -- a是输出行数，b是输出起始行（第一行计为0） SELECT column FROM dataset LIMIT a OFFSET b   使用;结束一条SQL语句，本文中省略；
  返回未排序数据；
  2. 排序 -- 按照一列或者多列升序排序 -- 可以按照“不查询”的列排序 -- 先按照column2排，再按照column5排 SELECT column1, column2, column3 FROM dataset ORDER BY column2, column5 -- 降序 -- DESC只作用于最靠近的唯一一列，即column2，不作用于column5 SELECT column1, column2, column3 FROM dataset ORDER BY column2 DESC, column5 --使用查询列相对编号 SELECT column1, column2, column3 FROM dataset ORDER BY 2, column5   使用相对列查询时，不查询的列，比如上述例子的column5，不能用数字代替。</description>
    </item>
    
    <item>
      <title>Python使用小技巧</title>
      <link>https://YulongNiu.github.io/posts/2015-07-28-python-tips/</link>
      <pubDate>Tue, 28 Jul 2015 14:37:38 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-07-28-python-tips/</guid>
      <description>收集了一些使用Python过程中的小技巧或者常见错误。
1. While&amp;ndash;if&amp;ndash;break 适用情况：当需要执行一个循环，但是不能事先判断何时终止。 可以在循环内部加入判断，符合要求时跳出。比如，使用程序在某个目录下新建一个文件夹，如果文件名已经存在，需要重新生成文件名；否则，创建文件夹。
import random, os while True: letter = [chr(i) for i in range(97, 123)] folderName = [random.choice(letter) for i in range(5)] fn = &amp;#39;&amp;#39;.join(folderName) if os.path.exists(fn) is not True: # get an unique name  os.mkdir(fn) break 2. 链式比较操作 Python支持一个链式的比较操作。
testNum = 10 # 链式比较操作 # 区别if not和if a is not None if (not 0 &amp;lt; testNum &amp;lt; 5): print(&amp;#39;It passed!&amp;#39;) 参考网址   Python Wiki</description>
    </item>
    
    <item>
      <title>估计RNA-seq转录本表达量和寻找差异表达基因</title>
      <link>https://YulongNiu.github.io/posts/2015-06-03-quantifing-rna-seq/</link>
      <pubDate>Wed, 03 Jun 2015 16:58:01 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-06-03-quantifing-rna-seq/</guid>
      <description>1. 标准化和计数 1.1 HTseq 简介：HTseq 是用于Python平台写成的处理高通量测序的平台。htseq-count可以用来对原始转录本计数，具体计数规则参考Counting reads in features with htseq-count。
平台：Python跨平台使用。
快速运行：
# 查看帮助 $ htseq-count --help # 对bam文件按照reads名称排序 $ samtools sort -n accepted_filtered.bam accepted_sortname # 注意“=”前后无空格 $ htseq-count --mode=union --stranded=no --type=exon --idattr=gene_id \ 	--format=bam accepted_sort.bam hg19USCS_ensembl.gtf &amp;gt; htseqcount_accepted.hsc 重要参数解释：
  --mode：统计落在某个基因上的reads数目的模型，默认值为“union”（图示）。作者认为“union”方法在绝大多数情况下都有很好的表现，建议使用。
  --stranded：测序方法，默认为“yes”。
  --type：计数单元类型，默认为GTF文件的exon。
  --idattr：计数单元归类，默认为gene_id。比如把合并汇报多个exon对应的一个gene。
  --format：可以输入bam或者sam文件，bam文件需要制定此参数。
  补充：
 如果输入的是bam文件，bam文件需要按照reads名称排序，操作方法为：  $ samtools sort -n accepted_filerted.bam acceted_sortname 1.2 GenomicAlignments GenomicAlignments是R/Bioconductor的一个包，其中summarizeOverlaps函数用于对alignment数据进行计数。</description>
    </item>
    
    <item>
      <title>UCSC Table下载注释文件</title>
      <link>https://YulongNiu.github.io/posts/2015-06-02-download-ucsc-gene-mask/</link>
      <pubDate>Tue, 02 Jun 2015 16:49:41 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-06-02-download-ucsc-gene-mask/</guid>
      <description>在进行RNA-seq数据分析时，需要从UCSC Table下载各种注释信息。比如Cufflinks等要求的转录组注释信息、Cufflinks建议去除的rRNA/tRNA/线粒体组注释。
1. 基因注释信息 下载转录组Ensembl注释文件：
在“table”选择中，ensemblSource表示Ensembl类型注释，ensemblToGeneName表示Ensembl到基因名注释对应。
2. rRNA注释信息 分为两步：
第一步， “table”选择wgEncodeGencodeBasicV19。
第二步，按照下图编辑“filter”。
3. tRNA注释信息 分为两步：
第一步，“track”选择 tRNA Genes。
第二步，保留pseudo tRNA注释。
4. 线粒体基因组注释 分为两步：
第一步， “table”选择wgEncodeGencodeBasicV19。
第二步，按照下图编辑“filter”。
参考资料   USCS Genome Browser的Google论坛：1、2
  另一种选择rRNA、tRNA和线粒体组注释的方法How to get tRNA/rRNA/mitochondrial gene GTF file
  Extract rRNA and tRNA features from UCSC Browser
  更新记录 2015年6月1日</description>
    </item>
    
    <item>
      <title>SSH建立端口转发</title>
      <link>https://YulongNiu.github.io/posts/2015-05-31-ssh-tunnel/</link>
      <pubDate>Sun, 31 May 2015 21:14:02 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-31-ssh-tunnel/</guid>
      <description>SSH建立端口转发分为两步：
1. 连接远程主机 $ ssh -NT -D 8080 usrname@host 其中，-N表示只连接远程主机，不打开远程shell；-T表示不分配TTY；-D表示某端口数据都通过SSH传向远程主机；8080可以设置为其他端口。
2. 添加Chrome浏览器支持 添加Proxy SwitchySharp插件，之后在SOCKS host栏目中填入地址127.0.0.1，端口8080并启用即可。
参考网址   SSH隧道翻墙的原理和实现
  SSH原理与运用（二）：远程操作与端口转发
  更新记录 2017年5月31日</description>
    </item>
    
    <item>
      <title>Bash简易编程</title>
      <link>https://YulongNiu.github.io/posts/2015-05-28-bash-program/</link>
      <pubDate>Thu, 28 May 2015 21:24:32 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-28-bash-program/</guid>
      <description>1. 循环 for循环体
for i in *.zip do echo &amp;#34;$i&amp;#34; done 2. 创建数组 declare -a testArray={&amp;#34;element1&amp;#34; &amp;#34;element2&amp;#34;} echo ${testArray[0]} for i in &amp;#34;${testArray[@]}&amp;#34; do echo &amp;#34;$i&amp;#34; done 3. 字符串分割 # write in file &amp;#34;testsplit.sh&amp;#34; IFS=&amp;#39;,&amp;#39; read -ra splitArray &amp;lt;&amp;lt;&amp;lt; &amp;#34;This,is,a,test&amp;#34; for i in &amp;#34;${splitArray[@]}&amp;#34; do echo &amp;#34;$i&amp;#34; done $ bash testsplit.sh This is a test 4. 屏幕输出存入变量 某个bash命令，比如ls -l存入变量，之后引用变量。
# 注意等号前后不能加空格 listOutput=`ls -l` echo &amp;#34;$listOutput&amp;#34; 5. 文件末尾添加内容 touch testfile printf &amp;#34;hello\n&amp;#34; &amp;gt; testfile printf &amp;#34;world\n&amp;#34; &amp;gt;&amp;gt; testfile 6.</description>
    </item>
    
    <item>
      <title>确定TopHat中mate-inner-dist参数</title>
      <link>https://YulongNiu.github.io/posts/2015-05-23-tophat-inner-distance/</link>
      <pubDate>Sat, 23 May 2015 19:08:19 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-23-tophat-inner-distance/</guid>
      <description>对于双端测序RNA-seq数据，TopHat在运行时候，有两个参数-r/--mate-inner-dist和--mate-std-dev分别标识一对reads的间隔长度的期望平均值和标准差，其默认值分别为50bp和20bp。这两个参数本身是个估计值，用于TopHat在map过程中确定一对reads是否匹配到基因组正确位置。如果能够准确设定这两个数值，将会提升TopHat结果的准确性和完整性，参考一个例子。
有两种方法获得这对参数的准确值：
第一种：获取RNA-seq实验建库方法，之后按照以下网址说明计算，RNA-seq差异表达分析工作流程。
第二种：根据RNA-seq数据进行估算，具体步骤为：
  使用TopHat默认参数先跑一遍。
  使用MISO的pe_utils工具估算。
  以下详细介绍pe_utils使用方法。
第一步， 下载对应物种的基因注释文件GTF或者GFF，比如USCS Table Browser（output format选择GTF）或者使用MISO提供的Ensembl版本。如果GTF文件，使用Cufflinks的gffread工具进行转换。
第二步，确定TopHat运行结果的bam文件与基因注释GFF文件，两者基因组命名方法一致。有的使用类似chr1命名，而另外一些使用1。如果不一致，建议修改GFF文件。
# 查看GFF文件中基因组命名 $ awk &amp;#39;{print $1}&amp;#39; hg19USCS.gff | sort -n | uniq -c # 查看bam文件中基因组命名 samtools view accepted_hits.bam | head -1000 | awk &amp;#39;{print $3}&amp;#39; | sort -n | uniq -c 第三步，筛选较长外显子，比如长度大于1000bp。MISO提供了exon_utils工具用于提取长外显子，但是我们没有能够成功运行过。因此这里提供一个R版本的脚本，比如基因注释文件名为hg19USCS.gff，输出筛选的文件名为hg19USCS_selected.gff。
gffFile &amp;lt;- read.table(&amp;#39;hg19USCS.gff&amp;#39;, stringsAsFactors = FALSE) gffExon &amp;lt;- gffFile[gffFile[, 3] == &amp;#39;exon&amp;#39;, ] exonLen &amp;lt;- abs(gffExon[, 5] - gffExon[, 4]) gffExonSelect &amp;lt;- gffExon[exonLen &amp;gt;= 1000, ] write.</description>
    </item>
    
    <item>
      <title>Python打包和上传PyPI</title>
      <link>https://YulongNiu.github.io/posts/2015-05-23-python-pkg/</link>
      <pubDate>Sat, 23 May 2015 01:03:26 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-23-python-pkg/</guid>
      <description>一个简单的Python包创建和上传PyPI流程。
1. 打包 ## 安装相关工具 pip install --upgrade setuptools wheel twine 当Python包代码完成后，在根目录下创建setup.py文件，具体参考sampleproject。
## 进入Python包目录 ## 测试 python setup.py test ## 打包 python setup.py sdist bdist_wheel 2. 上传PyPI PyPI注册帐号。
## 进入Python包目录 ## 上传 twine upload dist/* 参考网址   Packaging Python Projects
  twine package
  更新记录 2018年6月23日</description>
    </item>
    
    <item>
      <title>过滤TopHat分析双端测序的输出</title>
      <link>https://YulongNiu.github.io/posts/2015-05-16-filter-tophat2-output/</link>
      <pubDate>Sat, 16 May 2015 04:33:10 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-16-filter-tophat2-output/</guid>
      <description>0. 结论 在使用TopHat2匹配双端测序结果后，建议根据成对reads的map基因组位置唯一、方向正确和距离合适的标准，筛选得到的匹配结果。比如，TopHat2可能生成accepted_hits.bam文件，处理方法如下：
# 首先查看bam文件头部有多少行 $ samtools view -H accepted_hits.bam | wc -l 86 # 筛选成对且成功map到基因组唯一位置的reads，按照上一条输出结果，调整“NR &amp;lt;= 86” $ samtools view -h accepted_hits.bam | \  awk &amp;#39;{if (NR &amp;lt;= 86) print $0}; {if($5 == 50 &amp;amp;&amp;amp; ($2 == 163 || $2 == 147 || $2 == 83 || $2 == 99)) print $0}&amp;#39; | \  samtools view -b - &amp;gt; accepted_filtered.bam $ samtools view accepted_filtered.bam | wc -l 79143942 1.</description>
    </item>
    
    <item>
      <title>Django使用介绍</title>
      <link>https://YulongNiu.github.io/posts/2015-05-09-django-tutorial/</link>
      <pubDate>Sat, 09 May 2015 13:42:15 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-09-django-tutorial/</guid>
      <description>本文是学习Django Tutorial的记录，目的为了帮助快速浏览和查找Django使用细节。
1. 安装Django 本文使用Python 3.3.6和PostgreSQL 9.3.6学习Django。可以参考“使用Pyenv控制多个版本Python”和 “Fedora安装与使用PostgreSQL”，安装对应版本Python和PostgreSQL。
# 安装Django $ pip install django # 安装PostgreSQL支持psycopg2  $ pip install psycopg2 # 检查Django版本 $ python -c &amp;#34;import django; print(django.get_version())&amp;#34; 2. 创建项目 # 创建名为mysite的项目 $ django-admin startproject mysite 之后，配制数据库。修改mysite/settings.py对应位置。
# Database # https://docs.djangoproject.com/en/1.8/ref/settings/#databases DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.postgresql_psycopg2&amp;#39;, &amp;#39;NAME&amp;#39;: &amp;#39;testdb&amp;#39;, &amp;#39;USER&amp;#39;: &amp;#39;userName&amp;#39;, &amp;#39;PASSWORD&amp;#39;: &amp;#39;passWord&amp;#39;, &amp;#39;HOST&amp;#39;: &amp;#39;/var/run/postgresql&amp;#39;, &amp;#39;PORT&amp;#39;: &amp;#39;5432&amp;#39;, } } # 配制好数据库后，链接数据库 $ python manage.py migrate 开启Django测试网络服务器
$ python manage.</description>
    </item>
    
    <item>
      <title>使用Pyenv控制多个版本Python</title>
      <link>https://YulongNiu.github.io/posts/2015-05-09-python-different-version/</link>
      <pubDate>Sat, 09 May 2015 00:14:10 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-09-python-different-version/</guid>
      <description>同时在一台电脑上使用多个版本的Python，可以通过pyenv控制和管理。
1. 安装方法 $ git clone git://github.com/yyuu/pyenv.git ~/.pyenv # 写入路径信息 $ echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc $ echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc $ echo &amp;#39;eval &amp;#34;$(pyenv init -)&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc # 重新载入 $ source ~/.bashrc 2. 安装多个版本Python和对应包 ## 查看可提供的Python版本列表 $ pyenv install --list ## 安装Python所依赖包 $ sudo dnf install readline readline-devel readline-static openssl openssl-devel openssl-static sqlite-devel bzip2-devel bzip2-libs ## 安装其他版本Python ## 如果命令行下载安装Python太慢，可以将下载的安装包放入~/.pyenv/cache/文件夹中，之后安装 $ pyenv install 3.4.3 $ pyenv rehash ## 查看已安装Python版本 $ pyenv versions ## 全局切换Python版本 $ pyenv global 3.</description>
    </item>
    
    <item>
      <title>Fedora安装与使用PostgreSQL</title>
      <link>https://YulongNiu.github.io/posts/2015-05-08-install-use-postgresql/</link>
      <pubDate>Fri, 08 May 2015 18:30:54 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2015-05-08-install-use-postgresql/</guid>
      <description>1. 安装和开启postgresql Fedora直接使用dnf安装相关组件。
# 安装PostgreSQL $ sudo dnf install postgresql postgresql-server postgresql-contrib postgresql-devel pgadmin3 初始化（只需要执行一次）。如果出现类似Data directory is not empty!报错，可以尝试执行删除操作rm -f -r /usr/local/pgsql/data
# 初始化 $ sudo postgresql-setup --initdb --unit postgresql # 开启服务 $ sudo service postgresql start # 查询工作状态 $ sudo service postgresql status # 关闭服务 $ sudo service postgresql stop # 开机启动 $ sudo chkconfig postgresql on 2. 创建用户和数据库 为了方便使用，可以在PostgreSQL中创建一个与当前系统用户名相同的用户，比如目前系统登陆用户为Kitty。
# 进入home路径 $ cd /home/ # 进入默认postgres用户，需要输入root密码。 # 之后系统命令提示符会变成类似“bash-4.3$”。 $ sudo postgres # 创建用户 # -P：创建用户后立即创建密码 # -s：用户为superuser # -e：打印消息 bash-4.</description>
    </item>
    
    <item>
      <title>C语言学习记录</title>
      <link>https://YulongNiu.github.io/posts/2014-12-07-c-program-note/</link>
      <pubDate>Sun, 07 Dec 2014 18:23:16 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-12-07-c-program-note/</guid>
      <description>1. 基本数据类型 1.1 算术类型   类型 解释 说明 注意事项 本地字节数     short 有符号短整数 完整形式signed short int，singed和int可以省略 最左边一位表示符号，0为正数，1为负数 2   unsigned short 无符号短整数 完整形式unsigned short int，int可以省略 全部位占满 2   int 有符号整数 完整形式signed int，singed可以省略 最左边一位表示符号，0为正数，1为负数 4   unsigned int 无符号整数  全部位占满 4   long 有符号长整数 完整形式为signed long int，singed和int可以省略 最左边一位表示符号，0为正数，1为负数 8   unsigned long 无符号长整数 完整形式为unsigned short int，int可以省略 全部位占满 8   long long 无符号长长整数 完整形式为signed long long int，singed和int可以省略 C99特有 8   unsigned long long  有符号长长整数 完整形式为unsigned long long int，int可以省略 C99特有 8   char 字符 实质是“小整数”（可能比短整数占用字节更少） 分为char、singed char和unsigned char。使用单引号标记常量，比如&#39;A&#39;（值为65） 1   _Bool 布尔型整数 实质是无符号整数 只能赋值0或1，赋值_Bool类型变量为非零值会导致赋值为1 1   float 单精度浮点数   4   double 双精度浮点数   8   long double 扩展精度浮点数   16      强制编辑器处理常量为长整数（十进制、八进制和十六进制），1135L；强制处理为无符号，1135U；混合使用，1135UL，U和L顺序和大小写不重要。 C99中增加了ll或者LL后缀，强制long long int型整数，可以与u或U连用。避免无符号和有符号整数混用，特别是无符号和有符号整数比较，会产生意想不到的后果。</description>
    </item>
    
    <item>
      <title>Emacs配置C语言编程环境</title>
      <link>https://YulongNiu.github.io/posts/2014-12-01-emacs-config-c/</link>
      <pubDate>Mon, 01 Dec 2014 17:36:41 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-12-01-emacs-config-c/</guid>
      <description>有很多优秀的C语言IDE用来实现高效的编程，比如CLion。目前，CLion还在处于公开测试阶段，可以下载试用。本文介绍在Emacs下配置C/C++编程环境。
1. 安装和基本配置 1.1. 安装需求  安装GNU Global  # dnf install global llvm llvm-devel clang*   安装Emacs的helm、helm-swoop、helm-gtags、sr-speedbar、smartparens、google-c-style、auto-complete、auto-complete-c-headers、auto-complete-clang包。  1.2. Emacs配置 将附加环境设置添加到Emacs设置文件，比如~/.emacs，此环境配置参考tuhdo。
2. 文件操作## 2.1. 查找   当前buffer查找函数、类的定义
 C-c h i（helm-semantic-or-imenu）：可以输入部分关键词、空格等，以快速搜索。    当前project查找定义
  M-.（helm-gtags-dwim）：输入查找内容。M-,（tags-loop-continue）：返回上一个buffer。
  C-j（helm-gtags-select）：列出当前project所有定义，并且查找。
    查找引用
  C-c g r（helm-gtags-find-rtags）：光标停留在函数内部，查找该函数名；如果光标停留在函数名，查找该函数的所有引用。
  C-c g s（helm-gtags-find-symbol）：光标停留在变量时的查找。
    查找当前函数引用的函数
 C-c g a（helm-gtags-tags-in-this-function）    查找文件</description>
    </item>
    
    <item>
      <title>二代测序中的常用工具介绍</title>
      <link>https://YulongNiu.github.io/posts/2014-07-28-next-seqence-tools/</link>
      <pubDate>Mon, 28 Jul 2014 12:23:42 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-28-next-seqence-tools/</guid>
      <description>1. SAMtools 简介：SAMtools是用于处理SAM (Sequence Alignment/Map)格式文件的一系列工具，主要用来储存大容量的核酸测序结果。BAM是SAM文件的binary格式文件。SAMtools的主要作者是Heng Li，Heng Li在2012年因为对二代测序领域的贡献获得Benjamin Franklin Award。
平台：Mac OS/Linux
安装:
  下载SAMtools
  安装依赖的Ncurse库
  $ sudo dnf install ncurses*  添加SAMtools到PATH（设置参考）  快速运行
# sam格式文件转换为bam格式文件 # 新版本samtools不用使用-S $ samtools view -b samFile &amp;gt; bamFile # bam格式文件转换为sam格式文件 $ samtools view -h bamFile &amp;gt; samFile # bam格式文件转换为sorted bam格式文件，用于长期储存和后续分析 # 后一个‘sortedBamFilePrefix’是指需要存储文件名前缀，比如想存储“human_1.bam”，则输入“human_1” $ samtools sort bamFile sortedBamFilePrefix # bam文件按照reads名称排序 $ samtools sort -n bamFile sortedBamFilePrefix # 直接查看bam文件 $ samtools view bamFile | head -2 # 创建bam的index文件 $ samtools index bamFile # 输出alignment数目，配合-f和-F过滤reads $ samtools view -c bamFile # 统计bam文件map数量，可以用于评估mapping的质量。需要输入indexed的bam文件 # 输出结果每一列分别为参考序列名称、参考序列长度、map上的reads数目、未map上的reads数目 $ samtools idxstats sortedIndexedBamFile 重要参数解释：</description>
    </item>
    
    <item>
      <title>清洗二代测序数据</title>
      <link>https://YulongNiu.github.io/posts/2014-07-28-clean-seq-data/</link>
      <pubDate>Mon, 28 Jul 2014 20:11:18 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-28-clean-seq-data/</guid>
      <description>1. FastQC 简介：FastQC是用于对二代测序数据质量快速检验的工具，可以输入fastq（fastq.gz）、sam或者bam文件。查看输出结果解释。
平台：所有平台。
安装： 依赖Java，下载后直接安装使用。
快速运行：
# 输出分析结果至特定文档 $ fastqc seqFile1 --outdir setFolder1 # 支持批量处理测序数据 $ fastqc seqFile1 seqFile2 seqFileN # 查看帮助信息 $ fastqc --help # 查看一共分析了多少个reads，比如fastqc文件为“accepted_filtered_fastqc.zip” $ unzip -p accepted_filtered_fastqc.zip accepted_filtered_fastqc/fastqc_data.txt | \  sed -n &amp;#39;7 p&amp;#39; | \  awk &amp;#39;{print $3}&amp;#39; 2. Trim Galore! 简介：Trim Galore!是对FastQC和Cutadapt的包装。可以处理Illumina、Nextera 3和smallRNA测序平台的双端和单端数据，包括去除adapter和低质量reads。
平台：Linux
安装:
 需要先分别安装FastQC和Cutadapt，其中Cutadapt安装使用  # pip install cutadapt 快速运行：
# 处理双端测序结果 $ trim_galore --quality 20 --phred33 --stringency 3 --length 20 --paired \  --gzip --output_dir human_trimgalore \  mySeq_1_1.</description>
    </item>
    
    <item>
      <title>二代测序中的短序列比对</title>
      <link>https://YulongNiu.github.io/posts/2014-07-25-short-sequence-alignment/</link>
      <pubDate>Fri, 25 Jul 2014 14:04:25 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-25-short-sequence-alignment/</guid>
      <description>在二代测序数据分析中，非常重要的一步是将测得的短序列“对应”到基因组上。所使用的工具被称为“短序列比对工具（short sequence aligners）”。以下是一些常用工具的介绍。
1. Bowtie 简介：Bowtie2是现在广泛使用的序列比对工具。
运行方式：所有平台
特点：
  相比较Bowtie1，处理大于50bp的短序列，速度更快、也更敏感。Bowtie1在处理小于50bp的短序列上，效果更好。
  iGenomes提供一些事先编排（index）的基因组。
  快速运行：
# 建立一系列FASTA文件目录 $ bowtie2-build /filePath/genomeFastaFile indexName # 从已经index文件中提取原始基因组 $ bowtie2-inspect indexName &amp;gt; genomeFastaFile # unpaired序列比对 $ bowtie2 -p 4 -x indexName -U readFiles -S samFileName # paired序列比对 $ bowtie2 -p 4 -x indexName -1 readFiles1 -2 readFiles2 -S eg2.sam   -p：多线程
  -x：之后跟index名称
  -U：测序文件（比如Fasta，Fastq文件）
  -1/-2：标识paired文件
  -S：SAM格式输出文件</description>
    </item>
    
    <item>
      <title>RNA-Seq基本概念和数据分析流程</title>
      <link>https://YulongNiu.github.io/posts/2014-07-22-rna-seq-analysis/</link>
      <pubDate>Tue, 22 Jul 2014 17:03:15 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-22-rna-seq-analysis/</guid>
      <description>RNA-Seq相比较基因芯片，价格虽然昂贵一些，精度和灵敏度更高。同时，在测序深度足够时，也可以检测mRNA选择性剪切类型。
1. 样品制备 2. 测序 Illumina双端测序动画和图示。
3. 分析流程 RNA-Seq主要分析流程：
原始数据质量评估 --&amp;gt; 数据清洗（去除接头和低质量read） --&amp;gt; 清洗数据质量评估 --&amp;gt; map测序结果至基因组（转录组） --&amp;gt; map数据质量评估 --&amp;gt; 差异表达基因/选择性剪切/新基因/融合基因选择 --&amp;gt; GO和pathway分析 --&amp;gt; 共表达网络分析 3.1 序列清洗 序列清洗主要是去除测序结果中的adapter或通用引物等。
以下使用Illumina HiSeq2000平台，对一个人类样本的RNA测序。统计各种序列清洗方法和选择后的reads数目。原始数据两端测序reads分别为54,492,228和54,492,228。
  Method #Trimmed #Mapped* #Filtered     r50-notrim 108,984,456 109,278,388 79,143,942   r50-nomixed-notrim 108,984,456 103,548,800 79,143,942   r50-nomixed-trimmomatic-min20 104,164,622 116,315,394 80,337,256   r50-nomixed-trimmomatic-min36 101,548,172 110,778,108 79,248,896   r50-nomixed-trimmomatic-min50 98,525,312 106,659,988 77,779,424   r50-nomixed-galore-min20 107,097,862 114,943,386 83,039,928   r100-nomixed-galore-min20 107,097,862 114,944,672 87,899,316   r165sd45-nomixed-galore-min20 107,097,862 114,201,366 90,750,208   r165sd45G-nomixed-galore-min20 107,097,862 109,901,742 93,477,122   r165sd45-nomixed-galore-min50 104,869,208 109,258,544 89,329,672    *：使用TopHat2把序列mapped到hs19基因组。TopHat2默认设置为，如果一个reads能mapped到多个位点，则都会报道。因此数目可能比原始数据多。 4.</description>
    </item>
    
    <item>
      <title>Octopress安装和使用</title>
      <link>https://YulongNiu.github.io/posts/2014-07-22-octopress-install/</link>
      <pubDate>Tue, 22 Jul 2014 13:45:46 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-22-octopress-install/</guid>
      <description>安装和使用Octopress的一些注意事项，详细的内容可以参考网址。
1. 安装 请参考官网，其他的博客介绍的安装已经失效或者错误。 常用命令:
# 预览，可自动更新。使用Ctrl+c终止。 $ rake preview 2. Ruby版本调整 Octopress推荐使用RVM安装Ruby 2.2.10版本。在安转过程中可能会出现&amp;quot;gpg: Can&#39;t check signature: public key not found&amp;quot;的错误提示，需要执行一下类似命名，添加公用匙。
$ gpg2 --keyserver hkp://keys.gnupg.net --recv-keys D39DC0E3 使用以下操作设定ruby版本：
$ source ~/.rvm/scripts/rvm $ rvm use ruby-2.2.10 3. 预览错误 如果在预览博文时出现TCPServer Error: Address already in use - bind(2)的错误，表示端口（Octopress默认4000）被占，解决办法:
# 获取占据4000端口程序的PID $ lsof -wni tcp:4000 $ kill -9 PID 4. 更新博文 博文放置在source/_posts目录下。
$ rake new_post[&amp;#34;new post&amp;#34;] $ git add . $ git commit -m &amp;#34;my comment&amp;#34; $ git push origin source $ rake generate $ rake deploy # 或者generate和deploy一步执行 $ rake gen_deploy 如果需要在首页显示部分博文，在需要隔断的地方（博文markdown文件）加入：</description>
    </item>
    
    <item>
      <title>TopHat/Cufflinks/CummeRbund使用介绍</title>
      <link>https://YulongNiu.github.io/posts/2014-07-26-tophat-cufflinks-cummerbund/</link>
      <pubDate>Thu, 26 Jun 2014 14:51:56 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-07-26-tophat-cufflinks-cummerbund/</guid>
      <description>TopHat、Cufflinks和cummeRbund，被称为处理RNA-seq数据的“燕尾服（tuxedo）”。TopHat负责RNA-seq的reads映射比对到基因组，并且自动识别mRNA“内含子-外显子”剪切；Cufflinks擅长组装转录组和寻找差异表达基因（或转录起始位点TSS等）；cummeRbund主攻数据可视化。
1. Tophat 简介：TopHat是快速将RNA测序片段“对应（mapping）”到基因组上的工具，优势在于处理外显子间的剪切。内部首先使用bowtie或bowtie2把RNA测序片段“比对（alignment）”到基因组，之后再分析和鉴定剪切连接区域。
平台：Mac OS/Linux
快速运行：
# 双端测序 $ tophat2 -p 8 -o human_1 \  --mate-inner-dist 165 --mate-std-dev 45 --no-mixed \  hg19 human_1.fastq.gz human_2.fastq.gz # 单端测序 $ tophat2 -p 8 -o human_1 hg19 human_1.fastq.gz 重要参数解释：
  -p：设置线程数，用于多核计算。
  -o：执行输入文件夹。
  -r/--mate-inner-dist：一对reads的间隔长度的期望平均值，默认值为50bp，建议添加。具体解释，参考RNA-seq差异表达分析工作流程和Tophat中-r/–mate-inner-dist参数。
  --mate-std-dev：一对reads的间隔长度分布的标准差，默认值为20bp，建议添加。-r/--mate-inner-dist和--mate-std-dev的估计方法参考确定TopHat中mate-inner-dist参数。
  --library-type：
  测序仪器和方法，默认为标准Illumina平台的fr-unstranded。其他平台设置，详见TopHat说明文档、How to tell which library type to use (fr-firststrand or fr-secondstrand)?和链特异性转录组原理。
  如果分不清楚fr-firststrand和fr-secondstrand，推荐两种方法：第一种用两个参数试运行一个有1M reads的小样本，之后比较junction.bed大小；第二种在两个双端测序文件（fastq.gz）中抽取一些reads，之后Blat到USCS genomes上观察。</description>
    </item>
    
    <item>
      <title>R使用parallel包并行计算</title>
      <link>https://YulongNiu.github.io/posts/2014-06-24-parallel-package/</link>
      <pubDate>Tue, 24 Jun 2014 22:10:20 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-06-24-parallel-package/</guid>
      <description>最新版本的R已经内置parallel包，parallel包是从snow包和multicore包继承而来，包含了很多非常好用的函数。parallel包可以通过PVM（rpvm包）、MPI（Rmpi包）、NetWorkSpaces（nws包）和raw sockets（如果以上3种都不能使用）平台进行分布计算，支持cluster和多核个人/服务器计算机。在Linux系统上，通常使用openMPI。
1. 安装Rmpi包 因为使用openMPI，所以parallel包需要Rmpi包来设定节点，所以首先需要在计算机上安装openMPI。
1.1 Linux系统下安装openMPI环境 # 安装openmpi环境 # yum install openmpi openmpi-devel # 配置环境（安装时执行，可能之后运行也要执行） # ldconfig /usr/lib64/openmpi/lib/ 在~/.bashrc下写入
export LD_LIBRARY_PATH=&amp;#34;${LD_LIBRARY_PATH}${LD_LIBRARY_PATH:+:}/usr/lib64/openmpi/lib/&amp;#34; 载入~/.bashrc
$ source ~/.bashrc 1.2 安装Rmpi包 在启动的R窗口中输入：
install.packages(&amp;#34;Rmpi&amp;#34;, configure.args = c(&amp;#34;--with-Rmpi-include=/usr/include/openmpi-x86_64/&amp;#34;, &amp;#34;--with-Rmpi-libpath=/usr/lib64/openmpi/lib/&amp;#34;, &amp;#34;--with-Rmpi-type=OPENMPI&amp;#34;)) 2. 使用parallel包 2.1 设定节点数 首先，需要设定cluster的节点（nodes）数目
cl &amp;lt;- makeCluster(2, type = &amp;#34;MPI&amp;#34;) 这里对“节点数”设定做一些解释，如果使用cluster，可以直接设定cluster数据即可；如果是在小型服务器或者个人电脑上使用，最大节点数可以设定为“线程数（processor）-1”。比如一个双核四线程计算机，节点数目最大可以设定为3。这是因为snow包（parallel包的主要依赖包）在设计时，总是要保留一个**“主线程”**来处理和整合数据。
在linux系统下，线程数可以通过 $ nproc 查看。
2.2 内置函数 使用parallel包中的内置并行运算函数 比如使用parApply()、parCapply()、parRapply()、parLapply()和parSapply()（如果返回矩阵，使用 cbind()）等函数。其中文档中指出，parApply()函数对于二维矩阵的每一个单元进行操作，因此要慢一些。如果可能，使用parCapply()和parRapply()对列和行进行操作，以加快运行速度。
2.3 回收节点 stopCluster(cl) 3. 并行计算的包依赖问题 在并行计算过程中，不可避免地会用到其他包辅助。这里涉及到snow包的一个设计原理：并行运算多个R进程，只有一个主进程载入完整的依赖包环境。这就意味着其他并行的R进程中也要载入依赖的包环境。
有两个思路，第一个思路是修改Rprofile.site文件，让任意R进程在启动时都载入依赖的包。但是，不推荐这种做法，因为这样会增加R载入的速度；并且如果不同的代码用了不同的依赖包，就要不停地修改Rprofile.site文件。
第二个思路是在新开的R进程中“动态”加载需要的包。所谓**“动态”**，没有什么高深的意思，就是“需要的时候加载即可”。根据需要，可以选择以下两种方法。
 第一种方法是在直接在启动的R进程中加载包。  这种方法非常直观，推荐。
# 以下代码摘抄自Parallel R，其中packages # 是一个要选择加载的package列表， # 比如c(&amp;#39;bigmemory&amp;#39;, &amp;#39;foreach&amp;#39;, &amp;#39;doMC&amp;#39;) worker.</description>
    </item>
    
    <item>
      <title>构建和展示进化树软件使用心得</title>
      <link>https://YulongNiu.github.io/posts/2014-05-01-phylo-tool-summary/</link>
      <pubDate>Thu, 01 May 2014 17:13:59 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-05-01-phylo-tool-summary/</guid>
      <description>构建进化树 1. PhyML 构建进化树方法：Maximum Likelihood
评估：选择bootstrap或者Likelihood-ratio test
运行方式：所有平台和网页
心得：理论上支持4000条序列，小于2000000个字符。但是，对于个人电脑，通常100-200条序列比较合适。命令行运行时，可以选择非常简介的默认模式运行。在默认模式下，bootstrap需要手动开启。安装和使用非常方便，直接下载后可以直接使用。同时，bootstrap可以通过MPI分布计算，但是需要从源代码安装。
快速运行：
phyml -i align_file.phy --no_memory_check  -i：后跟需要Phylip格式文件 --no_memory_check：不用检查内存，防止程序运行时跳出  2. RAxML 构建进化树方法：Maximum Likelihood
运行方式：所有平台和网页。
心得：推荐网页运行，支持数据的存放和其他构建进化树的方法。本地安装支持MPI和PThreads的分布计算，但是安装有些复杂，需要仔细阅读文档。
快速运行1：
raxmlHPC-PTHREADS-AVX -x 12345 -p 12345 -# 100 -m GTRGAMMA -T 4 -s align_file.phy -n TEST  -x：bootstrap运行时设定随机数，用于结果重现 -p：parsimony推断时设定随机数，用于结果重现 -#：bootstrap次数。也可以设定为autoMRE，最大次数是1000。 -m：设定使用的模型，GTRGAMMA为核苷酸序列适用模型 -T：设定线程数，不要超过最大线程 -s：输入文件，Phylip或者fasta文件 -n：输入文件记号  快速运行2：
raxmlHPC-PTHREADS-AVX -f a -x 12345 -p 12345 -# autoMRE -m GTRCAT -T 4 -s align_file.phy -n TEST  -f a：选定算法，快速bootstrap  展示进化树 1.</description>
    </item>
    
    <item>
      <title>创建R包的最简流程</title>
      <link>https://YulongNiu.github.io/posts/2014-03-27-creat-r-package/</link>
      <pubDate>Thu, 27 Mar 2014 14:53:05 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-03-27-creat-r-package/</guid>
      <description>一个最简单创建R包的流程。
1. 载入工具包 安装并载入devtools包和roxygen2包。devtools包提供了一些包的检查、安装和打包的基本工具。roxygen2包则使得书写R帮助文档变得轻松简单。如果习惯使用Emacs，可以结合ESS建立R包，可以将R代码和帮助文档有效组合在一起，便于管理。当然，也可以使用Rstudio。
library(&amp;#39;devtools&amp;#39;) library(&amp;#39;roxygen2&amp;#39;) 2. Rcpp和相关的包 如果使用了Rcpp或者相关的包，比如RcppArmadillo，需要格外设置。所有cpp代码都写在src文件夹下。
首先，执行：
use_rcpp() 其次，在DESCRIPTION中添加依赖或者需要链接的包名称，比如：
Encoding: UTF-8 Imports: Rcpp LinkingTo: Rcpp, RcppArmadillo 之后，在包的R/目录下，添加一个文件RcppChk.R（文件名称自定），并写入：
#&amp;#39; @useDynLib my-pkg-name, .registration = TRUE #&amp;#39; @importFrom Rcpp sourceCpp NULL 注意，修改my-pkg-name为自己的包名称。
然后，在包的src/目录下，添加一个文件registerDynamicSymbol.c（文件名称自定），并写入：
// RegisteringDynamic Symbols  #include &amp;lt;R.h&amp;gt;#include &amp;lt;Rinternals.h&amp;gt;#include &amp;lt;R_ext/Rdynload.h&amp;gt; void R_init_markovchain(DllInfo* info) { R_registerRoutines(info, NULL, NULL, NULL, NULL); R_useDynamicSymbols(info, TRUE); } 最后，可能需要在~/.R/Makevars文件下添加：
# Settings from /etc/R/Makeconf with &amp;#34;non-portable flag(s):&amp;#34; # ‘-Wdate-time’ ‘-Werror=format-security’ ‘-Wformat’ replaced by -Wall -pedantic # and without -fdebug-prefix-map=.</description>
    </item>
    
    <item>
      <title>Circos Notes</title>
      <link>https://YulongNiu.github.io/posts/2014-03-17-circos-notes/</link>
      <pubDate>Mon, 17 Mar 2014 15:37:45 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2014-03-17-circos-notes/</guid>
      <description>Mapping data onto a Circos figure requires that you identify what patterns in your data are (a) likely to be important and (b) likely to be present, and create a figure that exposes such patterns. Remember, if the pattern exists, you can&amp;rsquo;t afford to miss it. If it doesn&amp;rsquo;t exist, you can&amp;rsquo;t afford to be fooled into thinking that it&amp;rsquo;s there, or left wondering whether it&amp;rsquo;s occluded by other data.</description>
    </item>
    
    <item>
      <title>A brief intruction of mutual information and demonstration with R</title>
      <link>https://YulongNiu.github.io/posts/2013-11-10-mutual-information/</link>
      <pubDate>Sun, 10 Nov 2013 01:21:16 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2013-11-10-mutual-information/</guid>
      <description>$\newcommand{\entropfrac}[2]{\frac{#1}{#2} \log \left( \frac{#1}{#2} \right)}$
Mututal Information (MI) Introduction Mutual Information (MI) is used to measure the distance between two genes vectors, for example $x_1 = {{1, 0, 1, 1, 1, 1, 0}}$ and $y_1 = {{0, 1, 1, 1, 1, 1, 0}}$. It is easily to transfer the two vectors into a binary table:
  X/Y 1 (Presence) 0 (Absence) Sum     1(Presence) a b a+b   0(Absence) c d c+d   Sum a+c b+d n=a+b+c+d    Typically, here we give the example of two discrete variables, the mutual information between $x_1$ and $y_1$ is</description>
    </item>
    
    <item>
      <title>R ggplot2 notes</title>
      <link>https://YulongNiu.github.io/posts/2013-10-02-ggplot2-notes/</link>
      <pubDate>Wed, 02 Oct 2013 02:47:11 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2013-10-02-ggplot2-notes/</guid>
      <description>R Package ggplot2Notes 1. Basic grammar 1.1 Plot types The R package ggplot2is a famous plot tool for high quality scientific figures. The ggplot2style figures are widely seen in papers published in high quality journals such as PNAS, Nature and Cell.
The input data should be in data frame form, and it is easily to use the function as.data.frame(). &amp;ldquo;+&amp;rdquo; is used to connect different plot statement. A typical ggplot2plot statement is like:</description>
    </item>
    
    <item>
      <title>探索EM算法</title>
      <link>https://YulongNiu.github.io/posts/2013-07-13-em/</link>
      <pubDate>Sat, 13 Jul 2013 19:23:22 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2013-07-13-em/</guid>
      <description>$$ \newcommand{\P}{\mathrm{P}} $$
$$ \DeclareMathOperator*{\argmax}{arg,max} $$
EM算法的推出 考虑观测数据$Y=\{y_1, y_2, \dots, y_m\}$，其中不可观测数据为$Z=\{z_1, z_2, \dots, z_k\}$，需要估计的参数为$\theta=\{\theta_1, \theta_2, \dots, \theta_t\}$。$Z$可以是离散或连续型随机变量，以下过程中假设$Z$为离散型（$Z$为连续型，则全概率公式由求和改为积分）。则观测数据的对数似然函数为：
$$ \begin{align} \begin{split} L(\theta) &amp;amp;= \log\left(\prod_{j=1}^m \P(y_j|\theta)\right) \newline &amp;amp;= \sum_{j=1}^m \log\left( \sum_{z \in Z} \P(y_j, z|\theta)\right) \end{split} \label{eq:1} \end{align} $$
为了使$L(\theta)$最大，很容易想到对$\theta$偏导求极值。但有一个困难，即$Z$不可观测，导致的直接后果是对数套求和，计算难度增加。直觉是，否能找到一个方法，将求和放在对数外面？ 一个常用的技巧是转化为不等式，Jensen&amp;rsquo;s inequality描述了积分的函数与函数的积分的关系。由于$\log(x)$是凹函数，尝试考察某一次特定的$\theta^{(n)}$取值后，$L(\theta)$与$L(\theta^{(n)})$的差：
$$ \begin{align} \begin{split} L(\theta) - L(\theta^{(n)}) &amp;amp;= \sum_{j=1}^m \log\left( \sum_{z \in Z} \P(y_j, z|\theta)\right) - L(\theta^{(n)}) \newline &amp;amp;= \sum_{j=1}^m \log\left( \sum_{z \in Z} \P(z|y_j, \theta^{(n)}) \frac{\P(y_j, z|\theta)}{\P(z|y_j, \theta^{(n)})}\right) - L(\theta^{(n)}) \newline &amp;amp;\geq \sum_{j=1}^m \sum_{z \in Z} \P(z|y_j, \theta^{(n)}) \log \left( \frac{\P(y_j, z|\theta)}{\P(z|y_j, \theta^{(n)})} \right) \newline &amp;amp;- \sum_{j=1}^m \sum_{z \in Z} \P(z|y_j, \theta^{(n)}) \log(\P(y_j|\theta^{n})) \newline &amp;amp;= \sum_{j=1}^m \sum_{z \in Z} \P(z|y_j, \theta^{(n)}) \log\left(\frac{\P(y_j, z|\theta)}{\P(y_j, z|\theta^{(n)})} \right) \end{split} \label{eq:2} \end{align} $$</description>
    </item>
    
    <item>
      <title>生物信息学工具网址</title>
      <link>https://YulongNiu.github.io/posts/2013-06-18-bioinfor-tools/</link>
      <pubDate>Tue, 18 Jun 2013 16:42:10 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2013-06-18-bioinfor-tools/</guid>
      <description>1. 基因组注释信息   NCBI ftp 下载基因组
  Craig Venter Institute
  Ensembl
  2. 进化树   进化树展示
  Wiki software list
  Biostats总结
  iTOL
  Dendroscope
    进化树构建
  RAxML
  PhyML
  PHYLIP，在PHYLIP的介绍中，列出了六个高使用率的构建进化树的软件，MrBayes、PAUP*、RAxML、PhyML、MEGA和PHYLIP。
    已知进化树
 Open Tree of Life    时间尺度进化树
 TimeTree    sRNA数据库</description>
    </item>
    
    <item>
      <title>统计学基本知识汇总</title>
      <link>https://YulongNiu.github.io/posts/2013-05-10-primary-statistic/</link>
      <pubDate>Fri, 10 May 2013 00:29:47 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2013-05-10-primary-statistic/</guid>
      <description>$$ \newcommand{\P}{\mathrm{P}} $$
1. 完备事件 对于完备事件组$X = \{x_1, x_2, \dots, x_n\}$：
$$ \begin{align} \begin{split} \P(x_1) + \P(x_2) + \dots + \P(x_n) = 1 \end{split} \label{eq:1} \end{align} $$
常用的技巧构造乘法系数，例如$\P(Y) = \sum\limits_{i=1}^{n}\P(x_i|\theta)\P(Y)$
2. 全概率公式 对于完备事件组$X = \{x_1, x_2, \dots, x_n\}$，事件$Y$的全概率公式：
$$ \begin{align} \begin{split} \P(Y) &amp;amp;= \P(Y, x_1) + \P(Y, x_2) + \dots + \P(Y, x_n) \newline &amp;amp;= \P(x_1)\P(Y|x_1) + \P(x_2)\P(Y|x_2) + \dots + \P(x_n)\P(Y|x_n) \end{split} \label{eq:2} \end{align} $$
使用概率密度函数表示为：
$$ \begin{align} \begin{split} f(Y) &amp;amp;= \int_{-\infty}^{+\infty}f(Y, x) \mathrm{d}x \newline &amp;amp;= \int_{-\infty}^{+\infty}f(Y|x)f(x) \mathrm{d}x \end{split} \label{eq:3} \end{align} $$</description>
    </item>
    
    <item>
      <title>Python中使用rpy2模块调用R</title>
      <link>https://YulongNiu.github.io/posts/2012-08-21-python-r-rpy2/</link>
      <pubDate>Tue, 21 Aug 2012 19:33:47 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-08-21-python-r-rpy2/</guid>
      <description>需要在python中调用R，实在是一种无奈的选择。如果能在一门语言中独立完成课题，是一个比较理想的做法。但是，这种想法也不太现实，毕竟每一种语言都有自己的长处。如果能取长补短，综合使用各种语言，也能起到不错的效果。
现在遇到的问题是，如何在python中调用R？这其中包括了如何调用R的对象（函数和包），R和python的对象如何互相转换，以及如何调用R的脚本（外界参数的输入）。python提供了一个模块rpy2 ，可以较好地完成这项工作。rpy2只是提供了一个Python调用R的接口，因此也直接继承了所有R的缺点。一个有意思的项目是renjin，一个基于JVM的R语言解释器。
本文着重记录一些使用过程中的注意事项和小技巧，如有不一致则以官方文档为准。
1. 安装 rpy2作为Python的一个模块，其安装非常方便。需要做的准备工作是在本地安装好R。
$ pip install rpy2 2. python调用R对象 2.1 使用rpy2.robjects 在rpy2中调用R对象，实际上是开启了一个R的交互进程。主要思路是将R的代码写入一个字符串内，之后执行即可。
对于R代码，将一段R代码写成一行，尽管看起来很丑陋而且不推荐，一样可以执行。但是，反过来，对于Python代码则没有这么简单。因为，Python代码是靠缩进来划分代码的区域，假若一段代码中有两个循环嵌套，如果将代码写成一行，执行起来就要麻烦的多（很可能要依赖空格的多少进行解释）。
调用方法：
from rpy2.robjects import r 有三种方式可以选择：
  使用r.obj，比如 r.c(1, 3)。这种方法虽然方便，但是对于名称中有“点号”的函数会出问题，比如 data.frame或者 read.csv等。
  使用r[&#39;obj&#39;]，比如 r[&#39;c&#39;](1, 3)。这种方法几乎可以调用任何R的函数，而且写法与原始调用很相似，无非是r[&#39;func&#39;](value1, para2 = value2)。如果一个R函数中的变量名是有“点号”的，不能直接赋值，需要构建一个字典形式，比如 r[&#39;func&#39;](value1, para2 = value, **{para.3: value3})。
  使用r(&#39;obj&#39;)，比如 r(&#39;c(1, 3)&#39;)。这种方法从某种程度上讲是万能的，因为总是可以将任意长度的R代码写成一个Python字符串，之后通过r(&#39;Rcode&#39;)调用执行。
  # import r &amp;gt;&amp;gt;&amp;gt; from rpy2.robjects import r # creat an R function &amp;gt;&amp;gt;&amp;gt; r(&amp;#39;&amp;#39;&amp;#39;f &amp;lt;- function(r){pi * r}&amp;#39;&amp;#39;&amp;#39;) &amp;gt;&amp;gt;&amp;gt; r.</description>
    </item>
    
    <item>
      <title>Emacs配置HTML/JS/CSS编辑环境</title>
      <link>https://YulongNiu.github.io/posts/2012-07-30-emacs-html-css-js/</link>
      <pubDate>Mon, 30 Jul 2012 22:31:13 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-07-30-emacs-html-css-js/</guid>
      <description>以下所有Emacs mode都使用Emacs包安装系统。
1. web-mode web-mode 提供了很好的wen配件（HTML、JavaScript、CSS、PHP等）的代码缩进、折叠和高亮等出色的功能。
有用技巧：
  C-c C-n：放在HTML标签上，在标签间跳转。
  C-c C-f：放在HTML标签上，在标签折叠。
  2. emmet-mode emmet-mode是emmet的Emacs扩展，取代了陈旧的ZenCoding。只需要输入制定的缩写，这个工具可以自动补全HTML标签。非常方便。
有用技巧：
  M-x emmet-mode：打开emmet-mode。
  C-j：自动补全。
  补全缩写规律：
  a：a+href
  #q：div+id(q)
  .x：div+class(x)
  #q.x：div+id(q)+class(x)
  附加内容 Emacs编程环境设置
;;;;;;;;;;;;;; ;emmet-mode ;;;;;;;;;;;;; (require &amp;#39;emmet-mode) (add-hook &amp;#39;sgml-mode-hook &amp;#39;emmet-mode) ;; Auto-start on any markup modes (add-hook &amp;#39;html-mode-hook &amp;#39;emmet-mode) (add-hook &amp;#39;web-mode-hook &amp;#39;emmet-mode) (add-hook &amp;#39;css-mode-hook &amp;#39;emmet-mode) ;;;;;;;;;;;;;; ;web-mode ;;;;;;;;;;;;;;; (require &amp;#39;web-mode) (add-to-list &amp;#39;auto-mode-alist &amp;#39;(&amp;#34;\\.</description>
    </item>
    
    <item>
      <title>Emacs高级使用技巧</title>
      <link>https://YulongNiu.github.io/posts/2012-06-24-emacs-extend-skills/</link>
      <pubDate>Sun, 24 Jun 2012 19:01:36 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-06-24-emacs-extend-skills/</guid>
      <description>1. Emacs配置文件位置 在Fedora系统下，Emacs的配置文件位置是~/.emacs。在Emacs配置文件中添加内容后，使用M-x eval-buffer，使当前配置生效。编译代码以加快加载速度，M-x byte-compile-file。
使用Eamcs解释器M-x ielm。
2. Emacs自带的包管理系统 在Emacs24之后，自带包管理系统，使用M-x eval-buffer进入。可以添加MELPA源、marmalade源、GNU源。
(require &amp;#39;package) (add-to-list &amp;#39;package-archives &amp;#39;(&amp;#34;melpa&amp;#34; . &amp;#34;http://melpa.milkbox.net/packages/&amp;#34;)) (add-to-list &amp;#39;package-archives &amp;#39;(&amp;#34;gnu&amp;#34; . &amp;#34;http://elpa.gnu.org/packages/&amp;#34;)) (package-initialize) 这样设置之后，就不需要类似(add-to-list &#39;load-path &amp;quot;~/.emacs.d/elpa/popup-20140207.1702/&amp;quot;)的语句了，因为Emacs会自动识别安装的包。但是，如果需要对某个包进行进一步设置，需要加上(require &#39;popup)之类的语句。
3. 显示行号 使用M-x linum-mode添加行号。如果需要永久显示，在Emacs配置文件中添加一下内容。
;;;;;;;;;;;;;;;;;;;;;;;;; ;open linum mode ;;;;;;;;;;;;;;;;;;;;;;;;; (setq linum-format &amp;#34;%4d \u2502&amp;#34;) (add-hook &amp;#39;prog-mode-hook &amp;#39;linum-mode) (add-hook &amp;#39;ess-mode-hook &amp;#39;linum-mode) 4. 进入Shell 三种方法：
  M-x shell
  M-x ansi-term
  M-x eshell
  5. root权限 C-x C-f 之后输入root密码/su:root@usrname password</description>
    </item>
    
    <item>
      <title>R包制作和roxygen2使用说明</title>
      <link>https://YulongNiu.github.io/posts/2012-05-29-r-package-and-roxygen2/</link>
      <pubDate>Tue, 29 May 2012 19:46:59 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-05-29-r-package-and-roxygen2/</guid>
      <description>查看创建R包的各种细节，权威的文献是Writing R Extensions。
1. 创建R包目录 像盖房子一样，创建R包需要先搭建一个骨架，这个骨架往往是固定的，即一些文件夹（如R，man等）和文件（如DESCRIPTION，NAMESPACE）是必须的，而另外一些则可选择性添加。一个典型的R包目录,比如Biobase包，如下图：
1.1 DESCRIPTION文件 一个纯文本ASCII文件，其中Package, Version, License, Description, Title, Author和Maintainer是必备条目，一个例子knitr包的DESCRIPTION文件：
  Package：由字母、数字和“点”构成的，至少含有两个字符，第一个必须是字母，结束不能用“点”（这也是包名称的命名规范）。
  Version：版本号，经典的命名方式比如0.1-0。
  License：GPL。
  Description：一段话描述包主要的功能。
  Title：包的一句话解释。
  Author和Maintainer：包的作者和维护者，姓+名 （比如Karl Pearson ）。也可以使使用Author@R描述作者，使用R函数person()，其中变量role的选项aut表示author，cre表示creator（维护者），ctb表示contributor。一个例子：
  c(person(&amp;#34;Hadley&amp;#34;, &amp;#34;Wickham&amp;#34;, email = &amp;#34;hadley@rice.edu&amp;#34;, role =&amp;#34;ctb&amp;#34;), person(&amp;#34;Yihui&amp;#34;, &amp;#34;Xie&amp;#34;, email = &amp;#34;xie@yihui.name&amp;#34;, role = c(&amp;#34;aut&amp;#34;, &amp;#34;cre&amp;#34;)))   Date（可选）：当前版本包日期，格式yyyy-mm-dd。
  Depends（可选）：依赖的R环境版本和包名称，比如 R (&amp;gt;= 2.14.1)。
  注意：   加上版本号，没有版本号等于没用，因为版本之间可能差异很大；
  对于base等这样的包就不用写了，因为是必然依赖的，同时也是R启动自动载入的。对于依赖的包名称，在R 2.</description>
    </item>
    
    <item>
      <title>R面向对象编程S4</title>
      <link>https://YulongNiu.github.io/posts/2012-05-05-r-s4/</link>
      <pubDate>Sat, 05 May 2012 15:19:36 +0800</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-05-05-r-s4/</guid>
      <description>1. 一些S3的铺垫 在博文“Linux安装R语言包”描述了如何查看一个函数的源代码，其中涉及了例如methods()函数，用来查看一个S3泛函（S3 generic）的方法。在pryr包中，提供了更加便捷的查看方法。
library(&amp;#39;pryr&amp;#39;) ## object is base type, S3, S4 or RC otype(obj) ## function is genetic or method ftype(method) 2. 类 2.1 建立新类 setClass(Class, representation, prototype, contains=character(), validity, access, where, version, sealed, package, S3methods = FALSE, slots)   Class：类名。     slots：带名字的列表或者字符向量，名字表示slot，内容表示slot对应的类名。     contains：父类名，表示继承关系。     prototype：带名setGroupGeneric字的列表或prototype()，设定默认值。不建议添加，如果不设定，会自动指定一个符合类型的空值。设定时，要结合validity定义，因为默认值不会被检查，因为即使不符合validity定义，也可以通过validObject()检查。     validity：函数，检查创建对象是否符合该类要求。建议添加，也可以使用setValidity()后期添加。     where：环境（少用）。     sealed：是否封闭，如果设定为TRUE，其他setClass()不能调用该类。     package：包名（少用）     S3methods/representation/access/version：在3.</description>
    </item>
    
    <item>
      <title>R小技巧集锦</title>
      <link>https://YulongNiu.github.io/posts/2012-05-02-r-tricks/</link>
      <pubDate>Wed, 02 May 2012 22:17:02 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2012-05-02-r-tricks/</guid>
      <description>持续更新R语言编程中的一些小技巧，包括一些易错点。但是，需要注意的，一旦需要使用一些非常稀奇古怪的技巧时，可以尝试反思是否是自己数据结构或者算法出了问题。
1. if爱你，else就要和你在一起，又要给你一些距离 if (con){ expr } else{ expr2 } if...else..结构中，}与else必须在同一行。
简易形式（不推荐）：
# else不能与expr在同一行 if (con) expr else expr2 建议将所有if ... else ...结构写成第一种形式，如果没有else，用else {}代替。
2. NULL是空，NULL是气，NULL在R中就是空气。## 如果表达式（expression）或者函数（function）的值没有定义，那么将返回NULL。在R中，NULL与很多对象合并在一起时，都被忽略掉。比如以下例子：
# NULL is neglected in vector &amp;gt; c(1, NA, NULL, FALSE) [1] 1 NA 0 # also in matrix &amp;gt; matrix(c(1, NA, NULL, 2), c(2, 2)) [,1] [,2] [1,] 1 2 [2,] NA 1 警告信息： In matrix(c(1, NA, NULL, 2), c(2, 2)) : 数据长度[3]不是矩阵行数[2]的整倍 # also in list &amp;gt; tmp &amp;lt;- list(1, 2) &amp;gt; tmp[1] &amp;lt;- NULL &amp;gt; tmp [[1]] [1] 2 &amp;gt; tmp[[1]] &amp;lt;- NULL &amp;gt; tmp list() 如果一定要将列表中的某个个元素赋值为NULL，可以使用list(NULL)，比如：</description>
    </item>
    
    <item>
      <title>Emacs和ESS的使用技巧</title>
      <link>https://YulongNiu.github.io/posts/2011-08-12-emacs-ess-tips/</link>
      <pubDate>Fri, 12 Aug 2011 17:20:57 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2011-08-12-emacs-ess-tips/</guid>
      <description>1. 安装ESS 有两种方法可以安装，一种是直接使用系统自带的包安装系统，比如yum：
$ sudo dnf install emacs-ess 但是，有时可能不是ESS最新版本。所以，推荐第二种方法，使用Emacs自带的包系统，方便更新及时，设置方法参考，安装ess包。
2. 使用ESS 进入GNU Emacs界面之后，输入M-X R 即可进入R界面。在这个过程中，会询问是否在当前运行目录下运行R，可以选择在不同目录下运行。
 M-x R：    启动R。R运行的buffer因为是在Emacs编辑器下运行，所以称为inferior（Emacs文档中称之为iESS buffer）。
  C-u M-x R RET --no-save RET：启动R并且不保存。
  M-x ess-transcript-clean-region：清理R界面。
  C-c C-z：强制停止运行的R进程。
   C-c C-x：    代替ls()函数。
  C-c C-s：代替search()函数。
  C-c C-d：修改已经建立的对象，非常实用。
   C-c C-n：    把当前行送到R。
  C-c C-c：把当前段送到R。
  C-c C-b：把当前整个文件送到R。</description>
    </item>
    
    <item>
      <title>Emacs使用汇总</title>
      <link>https://YulongNiu.github.io/posts/2011-08-12-emacs-tips/</link>
      <pubDate>Fri, 12 Aug 2011 14:57:17 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2011-08-12-emacs-tips/</guid>
      <description>1. 安装  ## 安装Emacs $ sudo dnf install emacs 2. 窗口和文件操作 Emacs的按键操作，约定C代表Ctrl键，M代表Alt键，RET表示Enter键。C-x对应字符扩展，比如C-x C-b表示列出所有buffer；M-x对应命令扩展，比如M-x replace-string（可以用TAB补全）表示字符替换。
 C-x 2或C-x 3：    将窗口分割成两个或者三个。
  C-x 1：只保留一个窗口。
  C-x n：开n个窗口
   C-x C-f：    读入文件，如果没有该文件，则自动创建这个文件，这个命令在mini buffer中呼出路径。
  对于Emacs minibuffer的路径，在Emacs中可以使用~/表示当前登录的用户，可以替代/home/usr。同时，可以在当前路径下直接输入/home//median/TOOL或者/home//~/进入需要的目录，因为Emacs会自动忽略//或者/~之前的内容（不能在终端使用它）。
  输入/su:root@localhost Mypassword：用以打开root权限文件。
  M-x ffap（find-file-at-point）：如果光标停留在一个路径上，可以直接打开这个路径对应目录的文件。
  一个更加酷的命令是Ido模式（Interactively Do Things），可以实现智能化的交互。打开方式：M-x ido-mode。
   补充Dired文件操作（Directory Editor）    在Dired buffer下，光标所在处+新建文件夹。
  f或e或者RET在当前buffer下打开文件。o在另一个buffer中打开文件，并且光标跳转到另一个buffer。C-o在另一个buffer下打开文件，光标保留在Dired buffer中。v在新的buffer打开文件，只读权限。^在新的buffer打开上层目录的Dired buffer。i在Dired buffer下打开文件夹。g更新状态。</description>
    </item>
    
    <item>
      <title>Linux常用命令集锦</title>
      <link>https://YulongNiu.github.io/posts/2010-11-08-linux-command/</link>
      <pubDate>Mon, 08 Nov 2010 18:00:40 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2010-11-08-linux-command/</guid>
      <description>1. 压缩与解压缩 .tar.gz格式文件
# 解压  $ tar -zxvf /filePath/filename.tar.gz # 压缩  $ tar -zcvf /filePath/filename.tar.gz /filePath/filename # 解压到特定文件夹 $ tar -zxvf /filePath/filename.tar.gz -C /filePath/filename # 压缩到特定文件夹 $ tar -zcvf /filePath/filename.tar.gz -C /filePath/filename # 压缩所有txt类型文件  $ gzip *.txt .tar.bz2格式文件
# 解压  $ tar -jxvf /filePath/filename.taz.bz2 # 压缩 $ tar -jcvf /filePath/filename.tar.bz2 /filePath/filename .rar格式文件
需要安装rar工具, 下载对应的linux版本，解压，make即可。
# 解压 $ rar e /filePath/filename.rar /filePath/filename # 压缩 $ rar a -m5 /filePath/filename.</description>
    </item>
    
    <item>
      <title>Linux安装R语言包</title>
      <link>https://YulongNiu.github.io/posts/2010-09-04-linux-install-r/</link>
      <pubDate>Sat, 04 Sep 2010 10:21:38 -0400</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2010-09-04-linux-install-r/</guid>
      <description>1. R包介绍 R的包（package）通常有两种:
  二进制代码包（Binary package）：这种包属于即得即用型（ready-to-use），但是依赖与平台，比如Windows和Linux平台下不同。
  源代码包（Source package）: 此类包可以跨平台使用，但用之前需要处理或者编译（compiled）。同时，源代码包可以查看到程序源代码，便于查找、修改和引用。
  2. R包安装 2.1 源代码安装 $ sudo R CMD INSTALL /.../myPackage.tar.gz 使用此方法，需要解决包依赖问题，即安装此包所依赖的包，安装过程有提示。
2.2 内置install.packages()函数安装### 使用install.packages()安装，比较简便，联网即可装，装了就可用。使用这种方法安装包时，R会自动安装依赖的包。如果出现安装报错，可能的原因是缺少依赖的系统文件。同时，需要注意的是，一些R包只能在特定的平台上使用。比如Rsubread不能在Windows操作系统下使用。
install.packages(&amp;#39;myPackage&amp;#39;) 同时，可以使用install.packages()安装本地下载的包，尤其适用于在服务器上安装包
install.packages( c(&amp;#39;XML_0.99-5.tar.gz&amp;#39;, &amp;#39;../../Interfaces/Perl/RSPerl_0.8-0.tar.gz&amp;#39;), repos = NULL, configure.args = c(XML = &amp;#39;--with-xml-config=xml-config&amp;#39;, RSPerl = &amp;#39;--with-modules= &amp;#34;IO Fcntl&amp;#34;&amp;#39;)) 3. R包版本查询和更新 R和R包版本查询
# 在启动的R中执行 R.version # R包版本 packageVersion(&amp;#39;myPackage&amp;#39;) # 查询当前R的详细信息，包括R版本、R包版本、命名空间等 sessionInfo() CRAN包更新
# 可以定期执行以下 update.packages() Bioconductor的安装和更新方法
source(&amp;#39;http://bioconductor.org/biocLite.R&amp;#39;) biocLite(&amp;#39;myPackage&amp;#39;) 4. 卸载R包## remove.packages(&amp;#39;myPackage&amp;#39;) 5. R包相关函数 # 查看包的安装目录 .</description>
    </item>
    
    <item>
      <title>Linux常用软件集锦</title>
      <link>https://YulongNiu.github.io/posts/2010-07-07-linux-software/</link>
      <pubDate>Wed, 07 Jul 2010 22:09:31 -0500</pubDate>
      
      <guid>https://YulongNiu.github.io/posts/2010-07-07-linux-software/</guid>
      <description>本文收集了一些好用或者好玩的Linux软件，使用Fedora示例。
1. 添加常用源   添加rpmfusion的free和nonfree源。
  添加FZUG源。一个中文Fedora的源和社区，在Fedora下安装中文软件等。
  2. 辅助安装工具   Fedy  Fedy是一个辅助在Fedora系统下，更容易安装Skypy、Chrome、Steam等的工具。
3. 影音  VLC  $ sudo dnf install vlc  Mplayer  $ sudo dnf install mplayer-gui xine smplayer  录音工具Audacity  $ sudo dnf install audacity  屏幕录制RecordMyDesktop  Linux下有很多录制屏幕的软件，推荐RecordMyDesktop。可以自己选定屏幕区域和大小，也可以把界面缩小到屏幕的下方，变成一个小的按钮，以方便操作。录制的文件为ogv格式，推荐使用VLC打开。
# 安装方法 $ sudo dnf install recordmydesktop # 使用方法 $ qt-recordMyDesktop 4. 办公  字典GoldenDict  Linux下曾经风靡一时的字典StarDict，现在有了更加先进和方便的接班人GoldenDict 。GoldenDict的主要特点有：
  字典库丰富;</description>
    </item>
    
  </channel>
</rss>
